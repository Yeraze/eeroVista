{% extends "base.html" %}

{% block title %}Dashboard - eeroVista{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
{% endblock %}

{% block content %}
<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; margin-bottom: 1.5rem;">
    <h1 style="margin: 0;">Network Dashboard</h1>
    <div style="display: flex; align-items: center; gap: 1rem;">
        <label for="network-selector" style="font-weight: 600; color: var(--subtext1);">Network:</label>
        <select id="network-selector" style="padding: 0.5rem 1rem; border: 1px solid var(--surface1); border-radius: 6px; background: var(--base); color: var(--text); font-size: 1rem; min-width: 200px;">
            <option value="">Loading...</option>
        </select>
    </div>
</div>

<div id="update-banner" style="background: var(--peach); color: var(--base); padding: 1rem 1.5rem; border-radius: 8px; margin-bottom: 1.5rem; align-items: center; gap: 1rem; display: none; cursor: pointer;" onclick="showReleaseNotesModal()">
    <div style="font-size: 1.5rem;">‚¨ÜÔ∏è</div>
    <div style="flex: 1;">
        <div style="font-weight: 600; font-size: 1rem;">Firmware Update Available</div>
        <div style="font-size: 0.875rem; margin-top: 0.25rem;">
            <span id="update-version"></span>
            <span id="update-date" style="margin-left: 0.5rem;"></span>
            <span style="margin-left: 0.5rem; text-decoration: underline;">Click for details</span>
        </div>
    </div>
</div>

<!-- Firmware Release Notes Modal -->
<div id="release-notes-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
    <div style="background: var(--base); border-radius: 12px; max-width: 600px; width: 90%; max-height: 80vh; display: flex; flex-direction: column; box-shadow: 0 4px 20px rgba(0,0,0,0.2);">
        <div style="padding: 1.5rem; border-bottom: 1px solid var(--surface1); display: flex; justify-content: space-between; align-items: center;">
            <h2 style="margin: 0; color: var(--text);" id="modal-title">eeroOS Update</h2>
            <button onclick="closeReleaseNotesModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--subtext0); padding: 0.25rem;">&times;</button>
        </div>
        <div id="modal-content" style="padding: 1.5rem; overflow-y: auto; flex: 1;">
            <p style="color: var(--subtext0);">Loading release notes...</p>
        </div>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-value" id="devices-online">--</div>
        <div class="stat-label">Devices Online</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="devices-total">--</div>
        <div class="stat-label">Total Devices</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="eero-nodes">--</div>
        <div class="stat-label">Eero Nodes</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="network-status">
            <span class="badge badge-success">Connected</span>
        </div>
        <div class="stat-label">Network Status</div>
    </div>
</div>

<div class="card">
    <div style="background: var(--surface0); padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem;">
        <p style="margin: 0; color: var(--subtext0); font-size: 0.875rem;">
            <strong>üì° Active Network:</strong> <span id="active-network-name" style="font-weight: 600; color: var(--text);">{{ network_name }}</span>
            <span style="margin-left: 0.5rem;">‚Ä¢ Use the network selector above to switch between networks</span>
            <span id="connection-mode-indicator" style="margin-left: 1rem; display: none;"></span>
        </p>
    </div>
    <p class="text-muted">Real-time monitoring and historical data collection</p>

    <div id="collection-status" style="margin-top: 1rem;">
        <p class="text-muted">
            <strong>Last Data Collection:</strong> <span id="last-collection-time">Checking...</span>
        </p>
        <p class="text-muted" style="font-size: 0.85rem;">
            {% if collection_interval_devices < 60 %}
                Device data collected every {{ collection_interval_devices }} seconds
            {% elif collection_interval_devices == 60 %}
                Device data collected every minute
            {% else %}
                Device data collected every {{ collection_interval_devices // 60 }} minutes
            {% endif %}
        </p>
    </div>
</div>

<div class="card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h2 class="card-title" style="margin: 0;">Bandwidth Usage</h2>
        <div id="bandwidth-controls" style="display: flex; gap: 0.5rem;">
            <button class="interval-btn" data-mode="hourly" onclick="updateNetworkBandwidthMode('hourly')">Hourly</button>
            <button class="interval-btn active" data-days="7" onclick="updateNetworkBandwidthDays(7)">7 Days</button>
            <button class="interval-btn" data-days="30" onclick="updateNetworkBandwidthDays(30)">30 Days</button>
        </div>
    </div>
    <div id="bridge-mode-bandwidth-message" style="display: none; padding: 2rem; text-align: center; background: var(--surface0); border-radius: 8px; color: var(--subtext0);">
        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üåâ</div>
        <div style="font-weight: 600; color: var(--text); margin-bottom: 0.5rem;">Bridge Mode Active</div>
        <div>Bandwidth calculations are not available in bridge mode</div>
    </div>
    <div id="bandwidth-summary" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
        <div style="text-align: center; padding: 0.75rem; background: var(--surface0); border-radius: 8px;">
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--blue);" id="today-download">--</div>
            <div style="font-size: 0.875rem; color: var(--subtext0);">Today Download</div>
        </div>
        <div style="text-align: center; padding: 0.75rem; background: var(--surface0); border-radius: 8px;">
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--mauve);" id="today-upload">--</div>
            <div style="font-size: 0.875rem; color: var(--subtext0);">Today Upload</div>
        </div>
        <div style="text-align: center; padding: 0.75rem; background: var(--surface0); border-radius: 8px;">
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text);" id="period-total">--</div>
            <div style="font-size: 0.875rem; color: var(--subtext0);" id="period-label">7 Day Total</div>
        </div>
    </div>
    <div id="bandwidth-chart-container" style="height: 300px; position: relative;">
        <canvas id="network-bandwidth-chart"></canvas>
    </div>
</div>

<!-- Current Bandwidth Usage Section -->
<div class="card">
    <h2 style="margin-bottom: 1rem; color: var(--text);">Current Bandwidth Usage</h2>
    <p style="color: var(--subtext0); font-size: 0.875rem; margin-bottom: 1rem;">Top 5 devices by current bandwidth from the latest poll</p>
    <div id="bridge-mode-current-message" style="display: none; padding: 2rem; text-align: center; background: var(--surface0); border-radius: 8px; color: var(--subtext0);">
        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üåâ</div>
        <div style="font-weight: 600; color: var(--text); margin-bottom: 0.5rem;">Bridge Mode Active</div>
        <div>Bandwidth calculations are not available in bridge mode</div>
    </div>
    <div id="current-bandwidth-container">
        <div id="current-bandwidth-list" style="display: flex; flex-direction: column; gap: 0.75rem;">
            <!-- Dynamically populated -->
        </div>
        <div id="current-bandwidth-empty" style="display: none; padding: 2rem; text-align: center; color: var(--subtext0);">
            No devices currently using bandwidth
        </div>
    </div>
</div>

<!-- Top Bandwidth Consumers Section (Historical) -->
<div class="card">
    <h2 style="margin-bottom: 1rem; color: var(--text);">Top Bandwidth Consumers (Historical)</h2>
    <div id="bridge-mode-devices-message" style="display: none; padding: 2rem; text-align: center; background: var(--surface0); border-radius: 8px; color: var(--subtext0);">
        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üåâ</div>
        <div style="font-weight: 600; color: var(--text); margin-bottom: 0.5rem;">Bridge Mode Active</div>
        <div>Bandwidth calculations are not available in bridge mode</div>
    </div>
    <div id="top-devices-chart-container" style="height: 350px; position: relative;">
        <canvas id="top-devices-chart"></canvas>
    </div>
</div>

<style>
    .interval-btn {
        padding: 0.25rem 0.75rem;
        background-color: var(--surface0);
        color: var(--text);
        border: 1px solid var(--surface1);
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
    }

    .interval-btn.active {
        background-color: var(--blue);
        color: white;
        border-color: var(--blue);
    }

    .interval-btn:hover:not(.active) {
        background-color: var(--surface1);
    }
</style>

<script>
    // Get current selected network
    function getSelectedNetwork() {
        const selector = document.getElementById('network-selector');
        return selector ? selector.value : null;
    }

    // Fetch dashboard statistics
    async function updateDashboardStats() {
        try {
            const network = getSelectedNetwork();
            const url = network ? `/api/dashboard-stats?network=${encodeURIComponent(network)}` : '/api/dashboard-stats';
            const response = await fetch(url);
            const data = await response.json();

            // Update stat cards
            document.getElementById('devices-online').textContent = data.devices_online || 0;
            document.getElementById('devices-total').textContent = data.devices_total || 0;
            document.getElementById('eero-nodes').textContent = data.eero_nodes || 0;

            // Update network status badge
            const statusElement = document.getElementById('network-status');
            const statusClass = data.wan_status === 'online' ? 'badge-success' :
                               data.wan_status === 'offline' ? 'badge-danger' : 'badge-warning';
            const statusText = data.wan_status || 'Unknown';
            statusElement.innerHTML = `<span class="badge ${statusClass}">${statusText}</span>`;

            // Update connection mode indicator (bridge mode detection)
            const modeIndicator = document.getElementById('connection-mode-indicator');
            const isBridge = data.connection_mode && data.connection_mode.toLowerCase() === 'bridge';

            if (data.connection_mode) {
                const modeText = isBridge ? 'üåâ Bridge Mode' : `Mode: ${data.connection_mode}`;
                const modeColor = isBridge ? 'var(--peach)' : 'var(--blue)';
                modeIndicator.innerHTML = `‚Ä¢ <span style="font-weight: 600; color: ${modeColor};">${modeText}</span>`;
                modeIndicator.style.display = 'inline';
            } else {
                modeIndicator.style.display = 'none';
            }

            // Show/hide bandwidth charts based on bridge mode
            const bridgeModeMessage = document.getElementById('bridge-mode-bandwidth-message');
            const bridgeModeDevicesMessage = document.getElementById('bridge-mode-devices-message');
            const bridgeModeCurrentMessage = document.getElementById('bridge-mode-current-message');
            const bandwidthSummary = document.getElementById('bandwidth-summary');
            const bandwidthChartContainer = document.getElementById('bandwidth-chart-container');
            const topDevicesChartContainer = document.getElementById('top-devices-chart-container');
            const currentBandwidthContainer = document.getElementById('current-bandwidth-container');
            const bandwidthControls = document.getElementById('bandwidth-controls');

            if (isBridge) {
                // Bridge mode: show message, hide charts
                bridgeModeMessage.style.display = 'block';
                bridgeModeDevicesMessage.style.display = 'block';
                bridgeModeCurrentMessage.style.display = 'block';
                bandwidthSummary.style.display = 'none';
                bandwidthChartContainer.style.display = 'none';
                topDevicesChartContainer.style.display = 'none';
                currentBandwidthContainer.style.display = 'none';
                bandwidthControls.style.display = 'none';
            } else {
                // Router mode: hide message, show charts
                bridgeModeMessage.style.display = 'none';
                bridgeModeDevicesMessage.style.display = 'none';
                bridgeModeCurrentMessage.style.display = 'none';
                bandwidthSummary.style.display = 'grid';
                bandwidthChartContainer.style.display = 'block';
                topDevicesChartContainer.style.display = 'block';
                currentBandwidthContainer.style.display = 'block';
                bandwidthControls.style.display = 'flex';
            }

            // Firmware update handling is done separately via loadFirmwareUpdateInfo()

        } catch (error) {
            console.error('Failed to fetch dashboard stats:', error);
        }
    }

    // Firmware update state
    let firmwareManifestUrl = null;
    let firmwareManifestData = null;

    // Load firmware update information
    async function loadFirmwareUpdateInfo() {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/firmware-update?network=${encodeURIComponent(network)}`
                : '/api/firmware-update';
            const response = await fetch(url);
            const data = await response.json();

            const updateBanner = document.getElementById('update-banner');
            const updateVersion = document.getElementById('update-version');
            const updateDate = document.getElementById('update-date');

            if (data.has_update && data.target_firmware) {
                // Show the banner
                updateBanner.style.display = 'flex';
                updateVersion.textContent = `Version: ${data.target_firmware}`;

                // Store manifest URL for modal
                firmwareManifestUrl = data.manifest_resource;

                // Fetch release date from manifest via proxy
                fetchReleaseDate();
            } else {
                updateBanner.style.display = 'none';
                firmwareManifestUrl = null;
                firmwareManifestData = null;
            }

        } catch (error) {
            console.error('Failed to fetch firmware update info:', error);
            document.getElementById('update-banner').style.display = 'none';
        }
    }

    // Fetch release date from manifest via proxy
    async function fetchReleaseDate() {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/firmware-manifest?network=${encodeURIComponent(network)}`
                : '/api/firmware-manifest';
            const response = await fetch(url);
            if (!response.ok) throw new Error('Failed to fetch manifest');
            const manifest = await response.json();

            if (manifest.error) {
                console.error('Manifest error:', manifest.error);
                return;
            }

            firmwareManifestData = manifest;

            const updateDate = document.getElementById('update-date');
            if (manifest.target && manifest.target.release_date) {
                const date = new Date(manifest.target.release_date);
                const formattedDate = date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
                updateDate.textContent = `‚Ä¢ Released ${formattedDate}`;
            }
        } catch (error) {
            console.error('Failed to fetch manifest:', error);
        }
    }

    // Show release notes modal
    function showReleaseNotesModal() {
        const modal = document.getElementById('release-notes-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');

        modal.style.display = 'flex';

        if (firmwareManifestData && firmwareManifestData.target) {
            const target = firmwareManifestData.target;
            modalTitle.textContent = target.title || 'eeroOS Update';

            let html = '';

            // Release date
            if (target.release_date) {
                const date = new Date(target.release_date);
                const formattedDate = date.toLocaleDateString('en-US', {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric'
                });
                html += `<p style="color: var(--subtext0); margin-bottom: 1.5rem;">Released: ${formattedDate}</p>`;
            }

            // Features/Release Notes
            if (target.features && target.features.length > 0) {
                html += '<h3 style="margin-bottom: 0.75rem; color: var(--text);">Release Notes</h3>';
                html += '<ul style="padding-left: 1.5rem; margin-bottom: 1rem; color: var(--text);">';
                target.features.forEach(feature => {
                    html += `<li style="margin-bottom: 0.5rem;">${feature}</li>`;
                });
                html += '</ul>';
            }

            modalContent.innerHTML = html || '<p style="color: var(--subtext0);">No release notes available.</p>';
        } else if (firmwareManifestUrl) {
            // Still loading or failed to load - try fetching via proxy
            modalContent.innerHTML = '<p style="color: var(--subtext0);">Loading release notes...</p>';
            const network = getSelectedNetwork();
            const url = network
                ? `/api/firmware-manifest?network=${encodeURIComponent(network)}`
                : '/api/firmware-manifest';
            fetch(url)
                .then(r => r.json())
                .then(manifest => {
                    if (manifest.error) {
                        modalContent.innerHTML = '<p style="color: var(--subtext0);">Unable to load release notes.</p>';
                        return;
                    }
                    firmwareManifestData = manifest;
                    showReleaseNotesModal();
                })
                .catch(() => {
                    modalContent.innerHTML = '<p style="color: var(--subtext0);">Unable to load release notes.</p>';
                });
        } else {
            modalContent.innerHTML = '<p style="color: var(--subtext0);">No release notes available.</p>';
        }
    }

    // Close release notes modal
    function closeReleaseNotesModal() {
        document.getElementById('release-notes-modal').style.display = 'none';
    }

    // Close modal when clicking outside
    document.getElementById('release-notes-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeReleaseNotesModal();
        }
    });

    // Close modal on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            closeReleaseNotesModal();
        }
    });

    // Fetch collection status
    async function updateCollectionStatus() {
        try {
            const response = await fetch('/api/collection-status');
            const data = await response.json();

            if (data.collections) {
                const deviceCollection = data.collections.device;

                if (deviceCollection && deviceCollection.timestamp) {
                    const secondsAgo = deviceCollection.seconds_ago;
                    const timeAgo = formatTimeAgo(secondsAgo);
                    const statusElement = document.getElementById('last-collection-time');

                    if (secondsAgo < 360) {  // Less than 6 minutes
                        statusElement.innerHTML = `<span style="color: var(--green);">${timeAgo}</span>`;
                    } else if (secondsAgo < 900) {  // Less than 15 minutes
                        statusElement.innerHTML = `<span style="color: var(--yellow);">${timeAgo}</span>`;
                    } else {
                        statusElement.innerHTML = `<span style="color: var(--red);">${timeAgo}</span>`;
                    }
                } else {
                    document.getElementById('last-collection-time').textContent = 'No data collected yet';
                }
            }
        } catch (error) {
            console.error('Failed to fetch collection status:', error);
            document.getElementById('last-collection-time').textContent = 'Error fetching status';
        }
    }

    function formatTimeAgo(seconds) {
        if (seconds < 60) {
            return `${seconds} seconds ago`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        } else {
            const hours = Math.floor(seconds / 3600);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        }
    }

    // Network bandwidth chart variables
    let networkBandwidthChart = null;
    let currentDays = 7;
    let currentMode = 'daily';  // 'hourly' or 'daily'

    // Top devices chart variable
    let topDevicesChart = null;

    // Format bytes to human readable format
    function formatBytes(mb) {
        if (mb >= 1000) {
            return `${(mb / 1000).toFixed(2)} GB`;
        }
        return `${mb.toFixed(2)} MB`;
    }

    // Load and render network bandwidth chart
    async function loadNetworkBandwidthChart(days) {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/network/bandwidth-total?days=${days}&network=${encodeURIComponent(network)}`
                : `/api/network/bandwidth-total?days=${days}`;
            const response = await fetch(url);
            const data = await response.json();

            if (!data.daily_breakdown || data.daily_breakdown.length === 0) {
                console.log('No network bandwidth data available');
                showNetworkNoDataMessage();
                return;
            }

            // Update summary stats
            updateBandwidthSummary(data, days, 'daily');

            // Render bar chart
            renderNetworkBandwidthChart(data.daily_breakdown, 'daily');
        } catch (error) {
            console.error('Failed to load network bandwidth chart:', error);
            showNetworkNoDataMessage();
        }
    }

    // Load and render hourly bandwidth chart
    async function loadNetworkBandwidthHourlyChart() {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/network/bandwidth-hourly?network=${encodeURIComponent(network)}`
                : '/api/network/bandwidth-hourly';
            const response = await fetch(url);
            const data = await response.json();

            if (!data.hourly_breakdown || data.hourly_breakdown.length === 0) {
                console.log('No hourly bandwidth data available');
                showNetworkNoDataMessage();
                return;
            }

            // Update summary stats
            updateBandwidthSummary(data, null, 'hourly');

            // Render bar chart
            renderNetworkBandwidthChart(data.hourly_breakdown, 'hourly');
        } catch (error) {
            console.error('Failed to load hourly bandwidth chart:', error);
            showNetworkNoDataMessage();
        }
    }

    function updateBandwidthSummary(data, days, mode) {
        if (mode === 'hourly') {
            // For hourly view, show today's totals
            document.getElementById('today-download').textContent = formatBytes(data.totals.download_mb);
            document.getElementById('today-upload').textContent = formatBytes(data.totals.upload_mb);
            document.getElementById('period-total').textContent = formatBytes(data.totals.total_mb);
            document.getElementById('period-label').textContent = 'Today Total';
        } else {
            // Get today's data (last entry in breakdown)
            const todayData = data.daily_breakdown[data.daily_breakdown.length - 1];

            if (todayData) {
                document.getElementById('today-download').textContent = formatBytes(todayData.download_mb);
                document.getElementById('today-upload').textContent = formatBytes(todayData.upload_mb);
            }

            // Show period total
            document.getElementById('period-total').textContent = formatBytes(data.totals.total_mb);
            document.getElementById('period-label').textContent = days === 7 ? '7 Day Total' : '30 Day Total';
        }
    }

    function showNetworkNoDataMessage() {
        const ctx = document.getElementById('network-bandwidth-chart');
        if (ctx) {
            // Destroy existing chart if present
            if (networkBandwidthChart) {
                networkBandwidthChart.destroy();
                networkBandwidthChart = null;
            }
            // Replace canvas with message
            const container = ctx.parentElement;
            container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--subtext0); font-size: 1rem;">Bandwidth data is accumulating... Check back soon!</div>';
        }
    }

    // Render network bandwidth bar chart
    function renderNetworkBandwidthChart(data, mode) {
        const ctx = document.getElementById('network-bandwidth-chart');
        if (!ctx) return;

        let labels, downloadData, uploadData, downloadColors, uploadColors, xAxisTitle, tooltipTitleFormatter, tickFormatter;
        let hasIncompleteData = false;

        if (mode === 'hourly') {
            // Hourly mode
            labels = data.map(d => d.hour_label);
            downloadData = data.map(d => d.download_mb);
            uploadData = data.map(d => d.upload_mb);
            downloadColors = data.map(() => 'rgba(30, 102, 245, 0.8)');
            uploadColors = data.map(() => 'rgba(136, 57, 239, 0.8)');
            xAxisTitle = 'Hour';

            tooltipTitleFormatter = function(context) {
                return context[0].label;
            };

            tickFormatter = function(value, index) {
                return this.getLabelForValue(value);
            };
        } else {
            // Daily mode - check for incomplete data
            labels = data.map(d => d.date);
            downloadData = data.map(d => d.download_mb);
            uploadData = data.map(d => d.upload_mb);

            // Use lighter colors for incomplete (today's) data
            downloadColors = data.map(d =>
                d.is_incomplete ? 'rgba(30, 102, 245, 0.4)' : 'rgba(30, 102, 245, 0.8)'
            );
            uploadColors = data.map(d =>
                d.is_incomplete ? 'rgba(136, 57, 239, 0.4)' : 'rgba(136, 57, 239, 0.8)'
            );

            hasIncompleteData = data.some(d => d.is_incomplete);
            xAxisTitle = 'Date';

            tooltipTitleFormatter = function(context) {
                // Parse ISO date as local date to avoid timezone shift
                const dateStr = context[0].label;
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const formatted = date.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric'
                });
                // Add note for incomplete data
                const dataPoint = data[context[0].dataIndex];
                return dataPoint.is_incomplete ? formatted + ' (incomplete)' : formatted;
            };

            tickFormatter = function(value, index) {
                // Parse ISO date as local date to avoid timezone shift
                const dateStr = this.getLabelForValue(value);
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric'
                });
            };
        }

        // Destroy and recreate chart when switching modes or when data structure changes
        // This ensures proper formatter updates and prevents "Invalid date" issues
        if (networkBandwidthChart) {
            networkBandwidthChart.destroy();
            networkBandwidthChart = null;
        }

        // Create new chart (first time only)
        networkBandwidthChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Download',
                        data: downloadData,
                        backgroundColor: downloadColors,
                        borderColor: 'rgb(30, 102, 245)',
                        borderWidth: 1
                    },
                    {
                        label: 'Upload',
                        data: uploadData,
                        backgroundColor: uploadColors,
                        borderColor: 'rgb(136, 57, 239)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: tooltipTitleFormatter,
                            label: function(context) {
                                return `${context.dataset.label}: ${formatBytes(context.parsed.y)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'category',  // Explicitly use category scale to prevent date parsing
                        stacked: false,
                        title: {
                            display: true,
                            text: xAxisTitle
                        },
                        ticks: {
                            callback: tickFormatter
                        }
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Data Usage (MB)'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000) {
                                    return (value / 1000).toFixed(1) + ' GB';
                                }
                                return value.toFixed(0) + ' MB';
                            }
                        }
                    }
                }
            }
        });
    }

    // Update network bandwidth mode (hourly or daily)
    function updateNetworkBandwidthMode(mode) {
        currentMode = mode;

        // Update button states
        document.querySelectorAll('.interval-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.mode === mode) {
                btn.classList.add('active');
            }
        });

        // Load hourly chart
        loadNetworkBandwidthHourlyChart();
    }

    // Update network bandwidth days (called from button onclick)
    function updateNetworkBandwidthDays(days) {
        currentDays = days;
        currentMode = 'daily';

        // Update button states
        document.querySelectorAll('.interval-btn').forEach(btn => {
            btn.classList.remove('active');
            if (parseInt(btn.dataset.days) === days) {
                btn.classList.add('active');
            }
        });

        // Reload charts with new days
        loadNetworkBandwidthChart(days);
        loadTopDevicesChart();
    }

    // Load top bandwidth consuming devices
    async function loadTopDevicesChart() {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/network/bandwidth-top-devices?days=${currentDays}&limit=5&network=${encodeURIComponent(network)}`
                : `/api/network/bandwidth-top-devices?days=${currentDays}&limit=5`;
            const response = await fetch(url);
            const data = await response.json();

            if (data && data.devices && data.devices.length > 0) {
                renderTopDevicesChart(data);
            }
        } catch (error) {
            console.error('Failed to load top devices bandwidth:', error);
        }
    }

    // Render stacked bar chart for top devices
    function renderTopDevicesChart(data) {
        const ctx = document.getElementById('top-devices-chart');
        if (!ctx) return;

        // Define color palette for devices (Catppuccin Latte colors)
        const colorPalette = [
            'rgba(30, 102, 245, 0.8)',   // Blue
            'rgba(136, 57, 239, 0.8)',   // Mauve
            'rgba(23, 146, 153, 0.8)',   // Teal
            'rgba(64, 160, 43, 0.8)',    // Green
            'rgba(223, 142, 29, 0.8)',   // Yellow
            'rgba(220, 138, 120, 0.8)'   // Rosewater (for "Other")
        ];

        // Handle empty data case
        if (!data.devices || data.devices.length === 0) {
            // Destroy existing chart if present
            if (topDevicesChart) {
                topDevicesChart.destroy();
                topDevicesChart = null;
            }
            // Hide canvas and show message (preserve canvas for future re-renders)
            ctx.style.display = 'none';
            let msgContainer = ctx.parentElement.querySelector('.no-data-message');
            if (!msgContainer) {
                msgContainer = document.createElement('p');
                msgContainer.className = 'no-data-message';
                msgContainer.style.cssText = 'text-align: center; padding: 2rem; color: var(--subtext0);';
                msgContainer.textContent = 'No bandwidth data available for the selected period.';
                ctx.parentElement.appendChild(msgContainer);
            }
            msgContainer.style.display = 'block';
            return;
        }

        // Hide message and show canvas when we have data
        ctx.style.display = 'block';
        const msgContainer = ctx.parentElement.querySelector('.no-data-message');
        if (msgContainer) {
            msgContainer.style.display = 'none';
        }

        // Create datasets for each device (stacked)
        const datasets = [];

        // Add each device as a separate dataset
        data.devices.forEach((device, index) => {
            const totalData = device.daily_download.map((download, i) =>
                download + device.daily_upload[i]
            );
            datasets.push({
                label: device.name,
                data: totalData,
                backgroundColor: colorPalette[index % colorPalette.length],
                borderColor: colorPalette[index % colorPalette.length].replace('0.8', '1'),
                borderWidth: 1
            });
        });

        // Add "Other" category
        if (data.other && data.other.total_mb > 0) {
            const otherTotal = data.other.daily_download.map((download, i) =>
                download + data.other.daily_upload[i]
            );
            const otherLabel = `Other (${data.other.device_count} devices)`;
            datasets.push({
                label: otherLabel,
                data: otherTotal,
                backgroundColor: colorPalette[colorPalette.length - 1],
                borderColor: colorPalette[colorPalette.length - 1].replace('0.8', '1'),
                borderWidth: 1
            });
        }

        // Format labels - parse as local dates to avoid timezone shift
        const labels = data.dates.map(dateStr => {
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
        });

        // Update existing chart if it exists and dataset count matches
        if (topDevicesChart && topDevicesChart.data.datasets.length === datasets.length) {
            // Update data without destroying chart (reduces flicker)
            topDevicesChart.data.labels = labels;
            topDevicesChart.data.datasets = datasets;
            topDevicesChart.update('none'); // 'none' disables animations for smoother update
            return;
        }

        // Destroy and recreate if dataset count changed or first time
        if (topDevicesChart) {
            topDevicesChart.destroy();
        }

        // Create new chart
        topDevicesChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 10
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                // Parse as local date to avoid timezone shift
                                const dateStr = data.dates[context[0].dataIndex];
                                const [year, month, day] = dateStr.split('-').map(Number);
                                const date = new Date(year, month - 1, day);
                                return date.toLocaleDateString('en-US', {
                                    weekday: 'short',
                                    month: 'short',
                                    day: 'numeric'
                                });
                            },
                            label: function(context) {
                                const value = context.parsed.y;
                                return `${context.dataset.label}: ${formatBytes(value)}`;
                            },
                            footer: function(context) {
                                const total = context.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${formatBytes(total)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Date'
                        }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Total Usage (MB)'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000) {
                                    return (value / 1000).toFixed(1) + ' GB';
                                }
                                return value.toFixed(0) + ' MB';
                            }
                        }
                    }
                }
            }
        });
    }

    // Load and render current bandwidth usage (top 5 from latest poll)
    async function loadCurrentBandwidth() {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/devices?network=${encodeURIComponent(network)}`
                : '/api/devices';
            const response = await fetch(url);
            const data = await response.json();

            const listContainer = document.getElementById('current-bandwidth-list');
            const emptyMessage = document.getElementById('current-bandwidth-empty');

            if (!data.devices || data.devices.length === 0) {
                listContainer.innerHTML = '';
                emptyMessage.style.display = 'block';
                return;
            }

            // Filter to online devices with bandwidth data and sort by total bandwidth
            const devicesWithBandwidth = data.devices
                .filter(d => d.is_online && (d.bandwidth_down_mbps > 0 || d.bandwidth_up_mbps > 0))
                .map(d => ({
                    name: d.name || d.hostname || d.mac_address,
                    down: d.bandwidth_down_mbps || 0,
                    up: d.bandwidth_up_mbps || 0,
                    total: (d.bandwidth_down_mbps || 0) + (d.bandwidth_up_mbps || 0),
                    type: d.type || 'unknown'
                }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 5);

            if (devicesWithBandwidth.length === 0) {
                listContainer.innerHTML = '';
                emptyMessage.style.display = 'block';
                return;
            }

            emptyMessage.style.display = 'none';

            // Find max total for bar scaling
            const maxTotal = devicesWithBandwidth[0].total;

            // Render the list with horizontal bars
            listContainer.innerHTML = devicesWithBandwidth.map((device, index) => {
                const barWidth = maxTotal > 0 ? (device.total / maxTotal * 100) : 0;
                const downPercent = device.total > 0 ? (device.down / device.total * 100) : 0;

                return `
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="width: 24px; text-align: center; font-weight: 600; color: var(--subtext0);">${index + 1}</div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                                <span style="font-weight: 500; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(device.name)}</span>
                                <span style="font-size: 0.875rem; color: var(--subtext0); white-space: nowrap; margin-left: 0.5rem;">
                                    ‚Üì${device.down.toFixed(1)} ‚Üë${device.up.toFixed(1)} Mbps
                                </span>
                            </div>
                            <div style="height: 8px; background: var(--surface1); border-radius: 4px; overflow: hidden;">
                                <div style="height: 100%; width: ${barWidth}%; display: flex; border-radius: 4px; overflow: hidden;">
                                    <div style="width: ${downPercent}%; background: var(--blue);"></div>
                                    <div style="flex: 1; background: var(--mauve);"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // Add legend
            listContainer.innerHTML += `
                <div style="display: flex; gap: 1.5rem; justify-content: center; margin-top: 0.75rem; font-size: 0.75rem; color: var(--subtext0);">
                    <span><span style="display: inline-block; width: 12px; height: 12px; background: var(--blue); border-radius: 2px; margin-right: 0.25rem; vertical-align: middle;"></span>Download</span>
                    <span><span style="display: inline-block; width: 12px; height: 12px; background: var(--mauve); border-radius: 2px; margin-right: 0.25rem; vertical-align: middle;"></span>Upload</span>
                </div>
            `;

        } catch (error) {
            console.error('Failed to load current bandwidth:', error);
            document.getElementById('current-bandwidth-list').innerHTML = '';
            document.getElementById('current-bandwidth-empty').style.display = 'block';
        }
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Load networks and populate dropdown
    async function loadNetworks() {
        try {
            const response = await fetch('/api/networks');
            const data = await response.json();

            const selector = document.getElementById('network-selector');
            selector.innerHTML = '';  // Clear existing options

            if (data.networks && data.networks.length > 0) {
                // Get selected network from localStorage (or default to first)
                const savedNetwork = localStorage.getItem('selectedNetwork');
                let selectedIndex = 0;

                data.networks.forEach((network, index) => {
                    const option = document.createElement('option');
                    option.value = network.name;
                    option.textContent = `${network.name} (${network.nickname_label})`;

                    // Check if this is the saved network
                    if (savedNetwork === network.name) {
                        selectedIndex = index;
                        option.selected = true;
                    } else if (!savedNetwork && index === 0) {
                        option.selected = true;
                    }

                    selector.appendChild(option);
                });

                // Save selected network on change and reload data
                selector.addEventListener('change', function() {
                    localStorage.setItem('selectedNetwork', this.value);
                    // Update the active network name display
                    const activeNetworkSpan = document.getElementById('active-network-name');
                    if (activeNetworkSpan) {
                        activeNetworkSpan.textContent = this.value;
                    }
                    // Reload all data for the new network
                    updateAll();
                });
            } else {
                selector.innerHTML = '<option value="">No networks available</option>';
            }
        } catch (error) {
            console.error('Failed to load networks:', error);
            document.getElementById('network-selector').innerHTML = '<option value="">Error loading networks</option>';
        }
    }

    // Update all data
    function updateAll() {
        updateDashboardStats();
        updateCollectionStatus();
        loadFirmwareUpdateInfo();

        // Load appropriate chart based on current mode
        if (currentMode === 'hourly') {
            loadNetworkBandwidthHourlyChart();
        } else {
            loadNetworkBandwidthChart(currentDays);
        }

        // Load current bandwidth usage (from latest poll)
        loadCurrentBandwidth();

        // Load top devices chart (historical)
        loadTopDevicesChart();
    }

    // Initial load
    async function initialize() {
        await loadNetworks();  // Wait for networks to load first
        updateAll();
    }
    initialize();

    // Update every 30 seconds
    setInterval(updateAll, 30000);
</script>
{% endblock %}
