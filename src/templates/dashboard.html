{% extends "base.html" %}

{% block title %}Dashboard - eeroVista{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
{% endblock %}

{% block content %}
<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; margin-bottom: 1.5rem;">
    <h1 style="margin: 0;">Network Dashboard</h1>
    <div style="display: flex; align-items: center; gap: 1rem;">
        <label for="network-selector" style="font-weight: 600; color: var(--subtext1);">Network:</label>
        <select id="network-selector" style="padding: 0.5rem 1rem; border: 1px solid var(--surface1); border-radius: 6px; background: var(--base); color: var(--text); font-size: 1rem; min-width: 200px;">
            <option value="">Loading...</option>
        </select>
    </div>
</div>

<div id="update-banner" style="display: none; background: var(--peach); color: var(--base); padding: 1rem 1.5rem; border-radius: 8px; margin-bottom: 1.5rem; align-items: center; gap: 1rem;">
    <div style="font-size: 1.5rem;">‚ö†Ô∏è</div>
    <div style="flex: 1;">
        <div style="font-weight: 600; font-size: 1rem;">Firmware Update Available</div>
        <div style="font-size: 0.875rem; margin-top: 0.25rem;">One or more eero nodes have firmware updates available. Visit the <a href="/nodes" style="color: var(--base); text-decoration: underline;">Nodes page</a> for details.</div>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-value" id="devices-online">--</div>
        <div class="stat-label">Devices Online</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="devices-total">--</div>
        <div class="stat-label">Total Devices</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="eero-nodes">--</div>
        <div class="stat-label">Eero Nodes</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="network-status">
            <span class="badge badge-success">Connected</span>
        </div>
        <div class="stat-label">Network Status</div>
    </div>
</div>

<div class="card">
    <div style="background: var(--surface0); padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem;">
        <p style="margin: 0; color: var(--subtext0); font-size: 0.875rem;">
            <strong>üì° Active Network:</strong> <span id="active-network-name" style="font-weight: 600; color: var(--text);">{{ network_name }}</span>
            <span style="margin-left: 0.5rem;">‚Ä¢ Use the network selector above to switch between networks</span>
        </p>
    </div>
    <p class="text-muted">Real-time monitoring and historical data collection</p>

    <div id="collection-status" style="margin-top: 1rem;">
        <p class="text-muted">
            <strong>Last Data Collection:</strong> <span id="last-collection-time">Checking...</span>
        </p>
        <p class="text-muted" style="font-size: 0.85rem;">
            {% if collection_interval_devices < 60 %}
                Device data collected every {{ collection_interval_devices }} seconds
            {% elif collection_interval_devices == 60 %}
                Device data collected every minute
            {% else %}
                Device data collected every {{ collection_interval_devices // 60 }} minutes
            {% endif %}
        </p>
    </div>
</div>

<div class="card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h2 class="card-title" style="margin: 0;">Bandwidth Usage</h2>
        <div style="display: flex; gap: 0.5rem;">
            <button class="interval-btn" data-mode="hourly" onclick="updateNetworkBandwidthMode('hourly')">Hourly</button>
            <button class="interval-btn active" data-days="7" onclick="updateNetworkBandwidthDays(7)">7 Days</button>
            <button class="interval-btn" data-days="30" onclick="updateNetworkBandwidthDays(30)">30 Days</button>
        </div>
    </div>
    <div id="bandwidth-summary" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
        <div style="text-align: center; padding: 0.75rem; background: var(--surface0); border-radius: 8px;">
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--blue);" id="today-download">--</div>
            <div style="font-size: 0.875rem; color: var(--subtext0);">Today Download</div>
        </div>
        <div style="text-align: center; padding: 0.75rem; background: var(--surface0); border-radius: 8px;">
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--mauve);" id="today-upload">--</div>
            <div style="font-size: 0.875rem; color: var(--subtext0);">Today Upload</div>
        </div>
        <div style="text-align: center; padding: 0.75rem; background: var(--surface0); border-radius: 8px;">
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text);" id="period-total">--</div>
            <div style="font-size: 0.875rem; color: var(--subtext0);" id="period-label">7 Day Total</div>
        </div>
    </div>
    <div style="height: 300px; position: relative;">
        <canvas id="network-bandwidth-chart"></canvas>
    </div>
</div>

<!-- Top Bandwidth Consumers Section -->
<div class="card">
    <h2 style="margin-bottom: 1rem; color: var(--text);">Top Bandwidth Consumers</h2>
    <div style="height: 350px; position: relative;">
        <canvas id="top-devices-chart"></canvas>
    </div>
</div>

<style>
    .interval-btn {
        padding: 0.25rem 0.75rem;
        background-color: var(--surface0);
        color: var(--text);
        border: 1px solid var(--surface1);
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
    }

    .interval-btn.active {
        background-color: var(--blue);
        color: white;
        border-color: var(--blue);
    }

    .interval-btn:hover:not(.active) {
        background-color: var(--surface1);
    }
</style>

<script>
    // Get current selected network
    function getSelectedNetwork() {
        const selector = document.getElementById('network-selector');
        return selector ? selector.value : null;
    }

    // Fetch dashboard statistics
    async function updateDashboardStats() {
        try {
            const network = getSelectedNetwork();
            const url = network ? `/api/dashboard-stats?network=${encodeURIComponent(network)}` : '/api/dashboard-stats';
            const response = await fetch(url);
            const data = await response.json();

            // Update stat cards
            document.getElementById('devices-online').textContent = data.devices_online || 0;
            document.getElementById('devices-total').textContent = data.devices_total || 0;
            document.getElementById('eero-nodes').textContent = data.eero_nodes || 0;

            // Update network status badge
            const statusElement = document.getElementById('network-status');
            const statusClass = data.wan_status === 'online' ? 'badge-success' :
                               data.wan_status === 'offline' ? 'badge-danger' : 'badge-warning';
            const statusText = data.wan_status || 'Unknown';
            statusElement.innerHTML = `<span class="badge ${statusClass}">${statusText}</span>`;

            // Show/hide update banner
            const updateBanner = document.getElementById('update-banner');
            if (data.updates_available) {
                updateBanner.style.display = 'flex';
            } else {
                updateBanner.style.display = 'none';
            }

        } catch (error) {
            console.error('Failed to fetch dashboard stats:', error);
        }
    }

    // Fetch collection status
    async function updateCollectionStatus() {
        try {
            const response = await fetch('/api/collection-status');
            const data = await response.json();

            if (data.collections) {
                const deviceCollection = data.collections.device;

                if (deviceCollection && deviceCollection.timestamp) {
                    const secondsAgo = deviceCollection.seconds_ago;
                    const timeAgo = formatTimeAgo(secondsAgo);
                    const statusElement = document.getElementById('last-collection-time');

                    if (secondsAgo < 360) {  // Less than 6 minutes
                        statusElement.innerHTML = `<span style="color: var(--green);">${timeAgo}</span>`;
                    } else if (secondsAgo < 900) {  // Less than 15 minutes
                        statusElement.innerHTML = `<span style="color: var(--yellow);">${timeAgo}</span>`;
                    } else {
                        statusElement.innerHTML = `<span style="color: var(--red);">${timeAgo}</span>`;
                    }
                } else {
                    document.getElementById('last-collection-time').textContent = 'No data collected yet';
                }
            }
        } catch (error) {
            console.error('Failed to fetch collection status:', error);
            document.getElementById('last-collection-time').textContent = 'Error fetching status';
        }
    }

    function formatTimeAgo(seconds) {
        if (seconds < 60) {
            return `${seconds} seconds ago`;
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        } else {
            const hours = Math.floor(seconds / 3600);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        }
    }

    // Network bandwidth chart variables
    let networkBandwidthChart = null;
    let currentDays = 7;
    let currentMode = 'daily';  // 'hourly' or 'daily'

    // Top devices chart variable
    let topDevicesChart = null;

    // Format bytes to human readable format
    function formatBytes(mb) {
        if (mb >= 1000) {
            return `${(mb / 1000).toFixed(2)} GB`;
        }
        return `${mb.toFixed(2)} MB`;
    }

    // Load and render network bandwidth chart
    async function loadNetworkBandwidthChart(days) {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/network/bandwidth-total?days=${days}&network=${encodeURIComponent(network)}`
                : `/api/network/bandwidth-total?days=${days}`;
            const response = await fetch(url);
            const data = await response.json();

            if (!data.daily_breakdown || data.daily_breakdown.length === 0) {
                console.log('No network bandwidth data available');
                showNetworkNoDataMessage();
                return;
            }

            // Update summary stats
            updateBandwidthSummary(data, days, 'daily');

            // Render bar chart
            renderNetworkBandwidthChart(data.daily_breakdown, 'daily');
        } catch (error) {
            console.error('Failed to load network bandwidth chart:', error);
            showNetworkNoDataMessage();
        }
    }

    // Load and render hourly bandwidth chart
    async function loadNetworkBandwidthHourlyChart() {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/network/bandwidth-hourly?network=${encodeURIComponent(network)}`
                : '/api/network/bandwidth-hourly';
            const response = await fetch(url);
            const data = await response.json();

            if (!data.hourly_breakdown || data.hourly_breakdown.length === 0) {
                console.log('No hourly bandwidth data available');
                showNetworkNoDataMessage();
                return;
            }

            // Update summary stats
            updateBandwidthSummary(data, null, 'hourly');

            // Render bar chart
            renderNetworkBandwidthChart(data.hourly_breakdown, 'hourly');
        } catch (error) {
            console.error('Failed to load hourly bandwidth chart:', error);
            showNetworkNoDataMessage();
        }
    }

    function updateBandwidthSummary(data, days, mode) {
        if (mode === 'hourly') {
            // For hourly view, show today's totals
            document.getElementById('today-download').textContent = formatBytes(data.totals.download_mb);
            document.getElementById('today-upload').textContent = formatBytes(data.totals.upload_mb);
            document.getElementById('period-total').textContent = formatBytes(data.totals.total_mb);
            document.getElementById('period-label').textContent = 'Today Total';
        } else {
            // Get today's data (last entry in breakdown)
            const todayData = data.daily_breakdown[data.daily_breakdown.length - 1];

            if (todayData) {
                document.getElementById('today-download').textContent = formatBytes(todayData.download_mb);
                document.getElementById('today-upload').textContent = formatBytes(todayData.upload_mb);
            }

            // Show period total
            document.getElementById('period-total').textContent = formatBytes(data.totals.total_mb);
            document.getElementById('period-label').textContent = days === 7 ? '7 Day Total' : '30 Day Total';
        }
    }

    function showNetworkNoDataMessage() {
        const ctx = document.getElementById('network-bandwidth-chart');
        if (ctx) {
            // Destroy existing chart if present
            if (networkBandwidthChart) {
                networkBandwidthChart.destroy();
                networkBandwidthChart = null;
            }
            // Replace canvas with message
            const container = ctx.parentElement;
            container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--subtext0); font-size: 1rem;">Bandwidth data is accumulating... Check back soon!</div>';
        }
    }

    // Render network bandwidth bar chart
    function renderNetworkBandwidthChart(data, mode) {
        const ctx = document.getElementById('network-bandwidth-chart');
        if (!ctx) return;

        let labels, downloadData, uploadData, downloadColors, uploadColors, xAxisTitle, tooltipTitleFormatter, tickFormatter;
        let hasIncompleteData = false;

        if (mode === 'hourly') {
            // Hourly mode
            labels = data.map(d => d.hour_label);
            downloadData = data.map(d => d.download_mb);
            uploadData = data.map(d => d.upload_mb);
            downloadColors = data.map(() => 'rgba(30, 102, 245, 0.8)');
            uploadColors = data.map(() => 'rgba(136, 57, 239, 0.8)');
            xAxisTitle = 'Hour';

            tooltipTitleFormatter = function(context) {
                return context[0].label;
            };

            tickFormatter = function(value, index) {
                return this.getLabelForValue(value);
            };
        } else {
            // Daily mode - check for incomplete data
            labels = data.map(d => d.date);
            downloadData = data.map(d => d.download_mb);
            uploadData = data.map(d => d.upload_mb);

            // Use lighter colors for incomplete (today's) data
            downloadColors = data.map(d =>
                d.is_incomplete ? 'rgba(30, 102, 245, 0.4)' : 'rgba(30, 102, 245, 0.8)'
            );
            uploadColors = data.map(d =>
                d.is_incomplete ? 'rgba(136, 57, 239, 0.4)' : 'rgba(136, 57, 239, 0.8)'
            );

            hasIncompleteData = data.some(d => d.is_incomplete);
            xAxisTitle = 'Date';

            tooltipTitleFormatter = function(context) {
                // Parse ISO date as local date to avoid timezone shift
                const dateStr = context[0].label;
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const formatted = date.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric'
                });
                // Add note for incomplete data
                const dataPoint = data[context[0].dataIndex];
                return dataPoint.is_incomplete ? formatted + ' (incomplete)' : formatted;
            };

            tickFormatter = function(value, index) {
                // Parse ISO date as local date to avoid timezone shift
                const dateStr = this.getLabelForValue(value);
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                return date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric'
                });
            };
        }

        // Destroy and recreate chart when switching modes or when data structure changes
        // This ensures proper formatter updates and prevents "Invalid date" issues
        if (networkBandwidthChart) {
            networkBandwidthChart.destroy();
            networkBandwidthChart = null;
        }

        // Create new chart (first time only)
        networkBandwidthChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Download',
                        data: downloadData,
                        backgroundColor: downloadColors,
                        borderColor: 'rgb(30, 102, 245)',
                        borderWidth: 1
                    },
                    {
                        label: 'Upload',
                        data: uploadData,
                        backgroundColor: uploadColors,
                        borderColor: 'rgb(136, 57, 239)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: tooltipTitleFormatter,
                            label: function(context) {
                                return `${context.dataset.label}: ${formatBytes(context.parsed.y)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'category',  // Explicitly use category scale to prevent date parsing
                        stacked: false,
                        title: {
                            display: true,
                            text: xAxisTitle
                        },
                        ticks: {
                            callback: tickFormatter
                        }
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Data Usage (MB)'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000) {
                                    return (value / 1000).toFixed(1) + ' GB';
                                }
                                return value.toFixed(0) + ' MB';
                            }
                        }
                    }
                }
            }
        });
    }

    // Update network bandwidth mode (hourly or daily)
    function updateNetworkBandwidthMode(mode) {
        currentMode = mode;

        // Update button states
        document.querySelectorAll('.interval-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.mode === mode) {
                btn.classList.add('active');
            }
        });

        // Load hourly chart
        loadNetworkBandwidthHourlyChart();
    }

    // Update network bandwidth days (called from button onclick)
    function updateNetworkBandwidthDays(days) {
        currentDays = days;
        currentMode = 'daily';

        // Update button states
        document.querySelectorAll('.interval-btn').forEach(btn => {
            btn.classList.remove('active');
            if (parseInt(btn.dataset.days) === days) {
                btn.classList.add('active');
            }
        });

        // Reload charts with new days
        loadNetworkBandwidthChart(days);
        loadTopDevicesChart();
    }

    // Load top bandwidth consuming devices
    async function loadTopDevicesChart() {
        try {
            const network = getSelectedNetwork();
            const url = network
                ? `/api/network/bandwidth-top-devices?days=${currentDays}&limit=5&network=${encodeURIComponent(network)}`
                : `/api/network/bandwidth-top-devices?days=${currentDays}&limit=5`;
            const response = await fetch(url);
            const data = await response.json();

            if (data && data.devices && data.devices.length > 0) {
                renderTopDevicesChart(data);
            }
        } catch (error) {
            console.error('Failed to load top devices bandwidth:', error);
        }
    }

    // Render stacked bar chart for top devices
    function renderTopDevicesChart(data) {
        const ctx = document.getElementById('top-devices-chart');
        if (!ctx) return;

        // Define color palette for devices (Catppuccin Latte colors)
        const colorPalette = [
            'rgba(30, 102, 245, 0.8)',   // Blue
            'rgba(136, 57, 239, 0.8)',   // Mauve
            'rgba(23, 146, 153, 0.8)',   // Teal
            'rgba(64, 160, 43, 0.8)',    // Green
            'rgba(223, 142, 29, 0.8)',   // Yellow
            'rgba(220, 138, 120, 0.8)'   // Rosewater (for "Other")
        ];

        // Handle empty data case
        if (!data.devices || data.devices.length === 0) {
            // Destroy existing chart if present
            if (topDevicesChart) {
                topDevicesChart.destroy();
                topDevicesChart = null;
            }
            // Hide canvas and show message (preserve canvas for future re-renders)
            ctx.style.display = 'none';
            let msgContainer = ctx.parentElement.querySelector('.no-data-message');
            if (!msgContainer) {
                msgContainer = document.createElement('p');
                msgContainer.className = 'no-data-message';
                msgContainer.style.cssText = 'text-align: center; padding: 2rem; color: var(--subtext0);';
                msgContainer.textContent = 'No bandwidth data available for the selected period.';
                ctx.parentElement.appendChild(msgContainer);
            }
            msgContainer.style.display = 'block';
            return;
        }

        // Hide message and show canvas when we have data
        ctx.style.display = 'block';
        const msgContainer = ctx.parentElement.querySelector('.no-data-message');
        if (msgContainer) {
            msgContainer.style.display = 'none';
        }

        // Create datasets for each device (stacked)
        const datasets = [];

        // Add each device as a separate dataset
        data.devices.forEach((device, index) => {
            const totalData = device.daily_download.map((download, i) =>
                download + device.daily_upload[i]
            );
            datasets.push({
                label: device.name,
                data: totalData,
                backgroundColor: colorPalette[index % colorPalette.length],
                borderColor: colorPalette[index % colorPalette.length].replace('0.8', '1'),
                borderWidth: 1
            });
        });

        // Add "Other" category
        if (data.other && data.other.total_mb > 0) {
            const otherTotal = data.other.daily_download.map((download, i) =>
                download + data.other.daily_upload[i]
            );
            const otherLabel = `Other (${data.other.device_count} devices)`;
            datasets.push({
                label: otherLabel,
                data: otherTotal,
                backgroundColor: colorPalette[colorPalette.length - 1],
                borderColor: colorPalette[colorPalette.length - 1].replace('0.8', '1'),
                borderWidth: 1
            });
        }

        // Format labels - parse as local dates to avoid timezone shift
        const labels = data.dates.map(dateStr => {
            const [year, month, day] = dateStr.split('-').map(Number);
            const date = new Date(year, month - 1, day);
            return date.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
        });

        // Update existing chart if it exists and dataset count matches
        if (topDevicesChart && topDevicesChart.data.datasets.length === datasets.length) {
            // Update data without destroying chart (reduces flicker)
            topDevicesChart.data.labels = labels;
            topDevicesChart.data.datasets = datasets;
            topDevicesChart.update('none'); // 'none' disables animations for smoother update
            return;
        }

        // Destroy and recreate if dataset count changed or first time
        if (topDevicesChart) {
            topDevicesChart.destroy();
        }

        // Create new chart
        topDevicesChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 10
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                // Parse as local date to avoid timezone shift
                                const dateStr = data.dates[context[0].dataIndex];
                                const [year, month, day] = dateStr.split('-').map(Number);
                                const date = new Date(year, month - 1, day);
                                return date.toLocaleDateString('en-US', {
                                    weekday: 'short',
                                    month: 'short',
                                    day: 'numeric'
                                });
                            },
                            label: function(context) {
                                const value = context.parsed.y;
                                return `${context.dataset.label}: ${formatBytes(value)}`;
                            },
                            footer: function(context) {
                                const total = context.reduce((sum, item) => sum + item.parsed.y, 0);
                                return `Total: ${formatBytes(total)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: 'Date'
                        }
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Total Usage (MB)'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000) {
                                    return (value / 1000).toFixed(1) + ' GB';
                                }
                                return value.toFixed(0) + ' MB';
                            }
                        }
                    }
                }
            }
        });
    }

    // Load networks and populate dropdown
    async function loadNetworks() {
        try {
            const response = await fetch('/api/networks');
            const data = await response.json();

            const selector = document.getElementById('network-selector');
            selector.innerHTML = '';  // Clear existing options

            if (data.networks && data.networks.length > 0) {
                // Get selected network from localStorage (or default to first)
                const savedNetwork = localStorage.getItem('selectedNetwork');
                let selectedIndex = 0;

                data.networks.forEach((network, index) => {
                    const option = document.createElement('option');
                    option.value = network.name;
                    option.textContent = `${network.name} (${network.nickname_label})`;

                    // Check if this is the saved network
                    if (savedNetwork === network.name) {
                        selectedIndex = index;
                        option.selected = true;
                    } else if (!savedNetwork && index === 0) {
                        option.selected = true;
                    }

                    selector.appendChild(option);
                });

                // Save selected network on change and reload data
                selector.addEventListener('change', function() {
                    localStorage.setItem('selectedNetwork', this.value);
                    // Update the active network name display
                    const activeNetworkSpan = document.getElementById('active-network-name');
                    if (activeNetworkSpan) {
                        activeNetworkSpan.textContent = this.value;
                    }
                    // Reload all data for the new network
                    updateAll();
                });
            } else {
                selector.innerHTML = '<option value="">No networks available</option>';
            }
        } catch (error) {
            console.error('Failed to load networks:', error);
            document.getElementById('network-selector').innerHTML = '<option value="">Error loading networks</option>';
        }
    }

    // Update all data
    function updateAll() {
        updateDashboardStats();
        updateCollectionStatus();

        // Load appropriate chart based on current mode
        if (currentMode === 'hourly') {
            loadNetworkBandwidthHourlyChart();
        } else {
            loadNetworkBandwidthChart(currentDays);
        }

        // Load top devices chart
        loadTopDevicesChart();
    }

    // Initial load
    async function initialize() {
        await loadNetworks();  // Wait for networks to load first
        updateAll();
    }
    initialize();

    // Update every 30 seconds
    setInterval(updateAll, 30000);
</script>
{% endblock %}
