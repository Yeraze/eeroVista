{% extends "base.html" %}

{% block title %}Eero Nodes - eeroVista{% endblock %}

{% block content %}
<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; margin-bottom: 1.5rem;">
    <h1 style="margin: 0;">Eero Nodes</h1>
    <div style="display: flex; align-items: center; gap: 1rem;">
        <label for="network-selector" style="font-weight: 600; color: var(--subtext1);">Network:</label>
        <select id="network-selector" style="padding: 0.5rem 1rem; border: 1px solid var(--surface1); border-radius: 6px; background: var(--base); color: var(--text); font-size: 1rem; min-width: 200px;">
            <option value="">Loading...</option>
        </select>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-value" id="total-nodes">--</div>
        <div class="stat-label">Total Nodes</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="online-nodes" style="color: var(--green);">--</div>
        <div class="stat-label">Online</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="gateway-node" style="color: var(--blue);">--</div>
        <div class="stat-label">Gateway</div>
    </div>
    <div class="stat-card">
        <div class="stat-value" id="connected-devices">--</div>
        <div class="stat-label">Total Connected Devices</div>
    </div>
</div>

<div class="card">
    <div class="card-title">Eero Mesh Nodes</div>
    <p class="text-muted">Physical eero devices in your mesh network</p>

    <div id="nodes-container" style="margin-top: 1.5rem;">
        <div style="text-align: center; padding: 2rem; color: var(--subtext0);">
            Loading nodes...
        </div>
    </div>
</div>

<div class="card" style="margin-top: 2rem;">
    <div class="card-title">Network Configuration</div>
    <p class="text-muted">IP reservations and port forwarding rules</p>

    <!-- Tabs -->
    <div style="display: flex; gap: 1rem; margin-top: 1.5rem; border-bottom: 2px solid var(--surface0);">
        <button class="routing-tab active" data-tab="reservations" onclick="switchRoutingTab('reservations')" style="background: none; border: none; padding: 0.75rem 1rem; cursor: pointer; font-weight: 600; color: var(--subtext0); border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.2s;">
            IP Reservations <span id="reservations-count" class="tab-count">0</span>
        </button>
        <button class="routing-tab" data-tab="forwards" onclick="switchRoutingTab('forwards')" style="background: none; border: none; padding: 0.75rem 1rem; cursor: pointer; font-weight: 600; color: var(--subtext0); border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.2s;">
            Port Forwards <span id="forwards-count" class="tab-count">0</span>
        </button>
    </div>

    <!-- IP Reservations Tab -->
    <div id="reservations-tab" class="routing-tab-content" style="margin-top: 1.5rem;">
        <div id="reservations-container">
            <div style="text-align: center; padding: 2rem; color: var(--subtext0);">
                Loading IP reservations...
            </div>
        </div>
    </div>

    <!-- Port Forwards Tab -->
    <div id="forwards-tab" class="routing-tab-content" style="margin-top: 1.5rem; display: none;">
        <div id="forwards-container">
            <div style="text-align: center; padding: 2rem; color: var(--subtext0);">
                Loading port forwards...
            </div>
        </div>
    </div>
</div>

<style>
    .node-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 1.5rem;
        margin-top: 1rem;
    }

    .node-card {
        background: var(--surface0);
        border: 1px solid var(--surface1);
        border-radius: 8px;
        padding: 1.5rem;
        transition: all 0.2s;
    }

    .node-card:hover {
        background: var(--surface1);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .node-card.offline {
        opacity: 0.6;
    }

    .node-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }

    .node-name {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text);
    }

    .node-status {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
    }

    .node-status.online {
        background: var(--green);
        color: var(--base);
    }

    .node-status.offline {
        background: var(--surface2);
        color: var(--subtext0);
    }

    .node-detail {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem 0;
        border-bottom: 1px solid var(--surface1);
        font-size: 0.875rem;
    }

    .node-detail:last-child {
        border-bottom: none;
    }

    .node-detail-label {
        color: var(--subtext0);
        font-weight: 500;
    }

    .node-detail-value {
        color: var(--text);
        font-weight: 600;
    }

    .gateway-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        background: var(--blue);
        color: var(--base);
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-top: 0.5rem;
    }

    .gateway-badge::before {
        content: "‚≠ê";
    }

    .update-badge {
        display: inline-block;
        background: var(--peach);
        color: var(--base);
        padding: 0.25rem 0.75rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
    }

    .mesh-quality {
        display: inline-flex;
        gap: 3px;
        align-items: center;
    }

    .mesh-bar {
        width: 8px;
        height: 16px;
        border-radius: 2px;
        transition: background-color 0.3s;
    }

    .mesh-bar.filled {
        opacity: 1;
    }

    .mesh-bar.empty {
        opacity: 0.2;
        background: var(--surface2);
    }

    /* Routing tab styles */
    .routing-tab.active {
        color: var(--blue) !important;
        border-bottom-color: var(--blue) !important;
    }

    .routing-tab:hover {
        color: var(--text);
        background: var(--surface0);
    }

    .tab-count {
        display: inline-block;
        background: var(--surface1);
        color: var(--subtext1);
        padding: 0.125rem 0.5rem;
        border-radius: 12px;
        font-size: 0.75rem;
        margin-left: 0.5rem;
    }

    .routing-tab.active .tab-count {
        background: var(--blue);
        color: var(--base);
    }

    .routing-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
    }

    .routing-table th {
        background: var(--surface0);
        padding: 0.75rem;
        text-align: left;
        font-weight: 600;
        color: var(--subtext1);
        border-bottom: 2px solid var(--surface1);
        font-size: 0.875rem;
    }

    .routing-table td {
        padding: 0.75rem;
        border-bottom: 1px solid var(--surface0);
        color: var(--text);
        font-size: 0.875rem;
    }

    .routing-table tr:hover {
        background: var(--surface0);
    }

    .ip-reserved {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
    }

    .forward-badge {
        display: inline-block;
        background: var(--blue);
        color: var(--base);
        padding: 0.125rem 0.5rem;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-right: 0.25rem;
    }

    .forward-badge.tcp {
        background: var(--blue);
    }

    .forward-badge.udp {
        background: var(--mauve);
    }

    .forward-badge.both {
        background: var(--green);
    }
</style>

<script>
    let nodesData = [];

    // Get current selected network
    function getSelectedNetwork() {
        const selector = document.getElementById('network-selector');
        return selector ? selector.value : null;
    }

    // Fetch nodes data
    async function loadNodes() {
        try {
            const network = getSelectedNetwork();
            const url = network ? `/api/nodes?network=${encodeURIComponent(network)}` : '/api/nodes';
            const response = await fetch(url);
            const data = await response.json();

            nodesData = data.nodes || [];

            // Update stats
            document.getElementById('total-nodes').textContent = nodesData.length;

            const onlineNodes = nodesData.filter(n => n.status === 'online').length;
            document.getElementById('online-nodes').textContent = onlineNodes;

            const gatewayNode = nodesData.find(n => n.is_gateway);
            document.getElementById('gateway-node').textContent = gatewayNode ? gatewayNode.location : 'N/A';

            const totalDevices = nodesData.reduce((sum, node) => sum + (node.connected_devices || 0), 0);
            document.getElementById('connected-devices').textContent = totalDevices;

            // Render nodes
            renderNodes();
        } catch (error) {
            console.error('Failed to load nodes:', error);
            document.getElementById('nodes-container').innerHTML =
                '<div style="text-align: center; padding: 2rem; color: var(--red);">Failed to load nodes</div>';
        }
    }

    function renderNodes() {
        const container = document.getElementById('nodes-container');

        if (nodesData.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--subtext0);">No nodes found</div>';
            return;
        }

        // Sort: gateway first, then by location
        const sortedNodes = [...nodesData].sort((a, b) => {
            if (a.is_gateway && !b.is_gateway) return -1;
            if (!a.is_gateway && b.is_gateway) return 1;
            return (a.location || '').localeCompare(b.location || '');
        });

        const nodesHTML = sortedNodes.map(node => {
            const statusClass = node.status === 'online' ? 'online' : 'offline';
            const cardClass = node.status === 'online' ? '' : 'offline';

            return `
                <div class="node-card ${cardClass}">
                    <div class="node-header">
                        <div class="node-name">${escapeHtml(node.location || 'Unknown Location')}</div>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <div class="node-status ${statusClass}">${node.status || 'unknown'}</div>
                            ${node.update_available ? '<div class="update-badge">Update Available</div>' : ''}
                        </div>
                    </div>

                    ${node.is_gateway ? '<div class="gateway-badge">Gateway Node</div>' : ''}

                    <div style="margin-top: 1rem;">
                        <div class="node-detail">
                            <span class="node-detail-label">Model</span>
                            <span class="node-detail-value">${escapeHtml(node.model || 'Unknown')}</span>
                        </div>
                        <div class="node-detail">
                            <span class="node-detail-label">Software Version</span>
                            <span class="node-detail-value">${escapeHtml(node.os_version || 'N/A')}</span>
                        </div>
                        <div class="node-detail">
                            <span class="node-detail-label">MAC Address</span>
                            <span class="node-detail-value">${escapeHtml(node.mac_address || 'N/A')}</span>
                        </div>
                        <div class="node-detail">
                            <span class="node-detail-label">Connected Devices</span>
                            <span class="node-detail-value">${node.connected_devices || 0} (${node.connected_wired || 0} wired, ${node.connected_wireless || 0} wireless)</span>
                        </div>
                        ${node.mesh_quality_bars !== null && node.mesh_quality_bars !== undefined ? `
                        <div class="node-detail">
                            <span class="node-detail-label">Mesh Quality</span>
                            <span class="node-detail-value">${renderMeshQuality(node.mesh_quality_bars)}</span>
                        </div>
                        ` : ''}
                        ${node.uptime ? `
                        <div class="node-detail">
                            <span class="node-detail-label">Uptime</span>
                            <span class="node-detail-value">${formatUptime(node.uptime)}</span>
                        </div>
                        ` : ''}
                        <div class="node-detail">
                            <span class="node-detail-label">Last Seen</span>
                            <span class="node-detail-value">${formatTimestamp(node.last_seen)}</span>
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        container.innerHTML = `<div class="node-grid">${nodesHTML}</div>`;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatUptime(seconds) {
        if (!seconds) return 'N/A';

        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);

        if (days > 0) {
            return `${days}d ${hours}h`;
        } else if (hours > 0) {
            return `${hours}h ${minutes}m`;
        } else {
            return `${minutes}m`;
        }
    }

    function formatTimestamp(timestamp) {
        if (!timestamp) return 'Never';

        const date = new Date(timestamp);
        const now = new Date();
        const diffSeconds = Math.floor((now - date) / 1000);

        if (diffSeconds < 60) {
            return 'Just now';
        } else if (diffSeconds < 3600) {
            const minutes = Math.floor(diffSeconds / 60);
            return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        } else if (diffSeconds < 86400) {
            const hours = Math.floor(diffSeconds / 3600);
            return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        } else {
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }
    }

    function renderMeshQuality(bars) {
        // Interpolate color from red (1) to green (5)
        // Using Catppuccin Latte colors
        const colors = [
            '#d20f39', // red (1 bar)
            '#fe640b', // peach (2 bars)
            '#df8e1d', // yellow (3 bars)
            '#8c9440', // olive (4 bars)
            '#40a02b'  // green (5 bars)
        ];

        const barsHTML = [];
        for (let i = 1; i <= 5; i++) {
            if (i <= bars) {
                const colorIndex = i - 1; // Use current bar index for progressive colors
                barsHTML.push(`<div class="mesh-bar filled" style="background-color: ${colors[colorIndex]};"></div>`);
            } else {
                barsHTML.push(`<div class="mesh-bar empty"></div>`);
            }
        }

        return `<div class="mesh-quality">${barsHTML.join('')}</div>`;
    }

    // Routing data
    let reservationsData = [];
    let forwardsData = [];

    // Load routing data
    async function loadRoutingData() {
        try {
            const network = getSelectedNetwork();

            // Load IP reservations
            const resUrl = network
                ? `/api/routing/reservations?network=${encodeURIComponent(network)}`
                : '/api/routing/reservations';
            const resResponse = await fetch(resUrl);
            if (resResponse.ok) {
                const resData = await resResponse.json();
                reservationsData = resData.reservations || [];
                document.getElementById('reservations-count').textContent = resData.count || 0;
                renderReservations();
            }

            // Load port forwards
            const fwdUrl = network
                ? `/api/routing/port-forwards?network=${encodeURIComponent(network)}`
                : '/api/routing/port-forwards';
            const fwdResponse = await fetch(fwdUrl);
            if (fwdResponse.ok) {
                const fwdData = await fwdResponse.json();
                forwardsData = fwdData.forwards || [];
                document.getElementById('forwards-count').textContent = fwdData.count || 0;
                renderForwards();
            }
        } catch (error) {
            console.error('Failed to load routing data:', error);
        }
    }

    // Switch routing tabs
    function switchRoutingTab(tab) {
        // Update tab buttons
        document.querySelectorAll('.routing-tab').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`.routing-tab[data-tab="${tab}"]`).classList.add('active');

        // Update tab content
        document.getElementById('reservations-tab').style.display = tab === 'reservations' ? 'block' : 'none';
        document.getElementById('forwards-tab').style.display = tab === 'forwards' ? 'block' : 'none';
    }

    // Render IP reservations table
    function renderReservations() {
        const container = document.getElementById('reservations-container');

        if (reservationsData.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--subtext0);">No IP reservations configured</div>';
            return;
        }

        const tableHTML = `
            <table class="routing-table">
                <thead>
                    <tr>
                        <th>IP Address</th>
                        <th>MAC Address</th>
                        <th>Description</th>
                        <th>Last Seen</th>
                    </tr>
                </thead>
                <tbody>
                    ${reservationsData.map(res => `
                        <tr>
                            <td><span class="ip-reserved">üîí ${escapeHtml(res.ip_address)}</span></td>
                            <td><code style="background: var(--surface0); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8125rem;">${escapeHtml(res.mac_address)}</code></td>
                            <td>${escapeHtml(res.description || 'N/A')}</td>
                            <td>${formatTimestamp(res.last_seen)}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;

        container.innerHTML = tableHTML;
    }

    // Render port forwards table
    function renderForwards() {
        const container = document.getElementById('forwards-container');

        if (forwardsData.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--subtext0);">No port forwards configured</div>';
            return;
        }

        const tableHTML = `
            <table class="routing-table">
                <thead>
                    <tr>
                        <th>IP Address</th>
                        <th>Ports</th>
                        <th>Protocol</th>
                        <th>Description</th>
                        <th>Last Seen</th>
                    </tr>
                </thead>
                <tbody>
                    ${forwardsData.map(fwd => `
                        <tr>
                            <td>${escapeHtml(fwd.ip_address)}</td>
                            <td><strong>${fwd.gateway_port}</strong> ‚Üí ${fwd.client_port}</td>
                            <td><span class="forward-badge ${fwd.protocol}">${fwd.protocol.toUpperCase()}</span></td>
                            <td>${escapeHtml(fwd.description || 'N/A')}</td>
                            <td>${formatTimestamp(fwd.last_seen)}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;

        container.innerHTML = tableHTML;
    }

    // Load networks and populate dropdown
    async function loadNetworks() {
        try {
            const response = await fetch('/api/networks');
            const data = await response.json();

            const selector = document.getElementById('network-selector');
            selector.innerHTML = '';  // Clear existing options

            if (data.networks && data.networks.length > 0) {
                // Get selected network from localStorage (or default to first)
                const savedNetwork = localStorage.getItem('selectedNetwork');

                data.networks.forEach((network, index) => {
                    const option = document.createElement('option');
                    option.value = network.name;
                    option.textContent = `${network.name} (${network.nickname_label})`;

                    // Check if this is the saved network
                    if (savedNetwork === network.name) {
                        option.selected = true;
                    } else if (!savedNetwork && index === 0) {
                        option.selected = true;
                    }

                    selector.appendChild(option);
                });

                // Save selected network on change and reload data
                selector.addEventListener('change', function() {
                    localStorage.setItem('selectedNetwork', this.value);
                    // Reload all data for the new network
                    loadNodes();
                    loadRoutingData();
                });
            } else {
                selector.innerHTML = '<option value="">No networks available</option>';
            }
        } catch (error) {
            console.error('Failed to load networks:', error);
            document.getElementById('network-selector').innerHTML = '<option value="">Error loading networks</option>';
        }
    }

    // Initial load
    loadNetworks();  // Load networks first
    loadNodes();
    loadRoutingData();

    // Refresh every 30 seconds
    setInterval(loadNodes, 30000);
    setInterval(loadRoutingData, 60000); // Routing data changes less frequently
</script>
{% endblock %}
