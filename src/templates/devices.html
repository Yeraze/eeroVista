{% extends "base.html" %}

{% block title %}Devices - eeroVista{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
{% endblock %}

{% block extra_css %}
<style>
    .device-row {
        transition: opacity 0.2s;
    }
    .device-row.offline {
        opacity: 0.5;
    }
    .sortable-header {
        cursor: pointer;
        user-select: none;
        position: relative;
        padding-right: 20px;
    }
    .sortable-header:hover {
        background-color: var(--surface0);
    }
    .sortable-header::after {
        content: '⇅';
        position: absolute;
        right: 5px;
        opacity: 0.3;
    }
    .sortable-header.sort-asc::after {
        content: '↑';
        opacity: 1;
    }
    .sortable-header.sort-desc::after {
        content: '↓';
        opacity: 1;
    }
    .status-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.875rem;
        font-weight: 500;
    }
    .status-online {
        background-color: var(--green);
        color: white;
    }
    .status-offline {
        background-color: var(--surface1);
        color: var(--subtext0);
    }

    /* Make rows clickable */
    .device-row {
        cursor: pointer;
    }
    .device-row:hover {
        background-color: var(--surface0);
    }

    /* Modal styles */
    .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .modal-overlay.active {
        display: flex;
    }

    .modal-content {
        background-color: var(--base);
        border: 2px solid var(--surface0);
        border-radius: 12px;
        padding: 1.5rem;
        max-width: 1000px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.75rem;
        border-bottom: 2px solid var(--surface0);
    }

    .modal-title {
        font-size: 1.25rem;
        font-weight: 600;
        color: var(--text);
        margin: 0;
    }

    .modal-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--subtext0);
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
    }

    .modal-close:hover {
        background-color: var(--surface0);
        color: var(--text);
    }

    .modal-body {
        color: var(--text);
    }

    .info-row {
        display: flex;
        padding: 0.5rem 0;
        border-bottom: 1px solid var(--surface0);
    }

    .info-row:last-child {
        border-bottom: none;
    }

    .info-label {
        font-weight: 600;
        color: var(--subtext1);
        min-width: 140px;
    }

    .info-value {
        color: var(--text);
        word-break: break-word;
    }

    .aliases-label {
        font-weight: 600;
        color: var(--subtext1);
        margin-bottom: 0.5rem;
        display: block;
    }

    .aliases-textarea {
        width: 100%;
        min-height: 100px;
        padding: 0.5rem;
        background-color: var(--mantle);
        color: var(--text);
        border: 1px solid var(--surface0);
        border-radius: 4px;
        font-family: monospace;
        font-size: 0.875rem;
        resize: vertical;
    }

    .aliases-textarea:focus {
        outline: none;
        border-color: var(--blue);
    }

    .aliases-help {
        font-size: 0.75rem;
        color: var(--subtext0);
        margin-top: 0.25rem;
    }

    .save-button {
        margin-top: 0.75rem;
        padding: 0.5rem 1rem;
        background-color: var(--blue);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
    }

    .save-button:hover {
        background-color: var(--sapphire);
    }

    .save-button:disabled {
        background-color: var(--surface1);
        color: var(--subtext0);
        cursor: not-allowed;
    }

    .save-message {
        display: none;
        margin-top: 0.5rem;
        padding: 0.5rem;
        border-radius: 4px;
        font-size: 0.875rem;
    }

    .save-message.success {
        display: block;
        background-color: var(--green);
        color: white;
    }

    .save-message.error {
        display: block;
        background-color: var(--red);
        color: white;
    }

    /* Bandwidth graph styles */
    .bandwidth-section {
        margin-top: 1rem;
        margin-bottom: 1.5rem;
    }

    .bandwidth-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }

    .bandwidth-title {
        font-weight: 600;
        color: var(--text);
        font-size: 1.1rem;
    }

    .interval-selector {
        display: flex;
        gap: 0.5rem;
    }

    .interval-btn {
        padding: 0.25rem 0.75rem;
        background-color: var(--surface0);
        color: var(--text);
        border: 1px solid var(--surface1);
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.875rem;
    }

    .interval-btn.active {
        background-color: var(--blue);
        color: white;
        border-color: var(--blue);
    }

    .interval-btn:hover:not(.active) {
        background-color: var(--surface1);
    }

    .chart-container {
        position: relative;
        height: 300px;
        margin-bottom: 1rem;
    }

    /* Two-column layout for device details and aliases */
    .details-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
        margin-top: 1.5rem;
    }

    .details-column {
        min-width: 0; /* Prevents grid overflow */
    }
</style>
{% endblock %}

{% block content %}
<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; margin-bottom: 1.5rem;">
    <h1 style="margin: 0;">Connected Devices</h1>
    <div style="display: flex; align-items: center; gap: 1rem;">
        <label for="network-selector" style="font-weight: 600; color: var(--subtext1);">Network:</label>
        <select id="network-selector" style="padding: 0.5rem 1rem; border: 1px solid var(--surface1); border-radius: 6px; background: var(--base); color: var(--text); font-size: 1rem; min-width: 200px;">
            <option value="">Loading...</option>
        </select>
    </div>
</div>

<!-- Routing data error notification -->
<div id="routing-error-notification" style="display: none; background: var(--yellow); color: var(--base); padding: 0.75rem 1rem; border-radius: 6px; margin-bottom: 1rem; display: none;">
    <strong>⚠ Warning:</strong> Unable to load IP reservation and port forward data. Some indicators may be missing.
</div>

<div class="card">
    <div class="card-title">Device List (<span id="device-count">0</span> devices, <span id="visible-count">0</span> shown)</div>
    <p class="text-muted">Click column headers to sort. Click on a device row to view details.</p>

    <!-- Filter controls -->
    <div style="display: flex; gap: 1rem; align-items: center; margin: 1rem 0; flex-wrap: wrap;">
        <div style="flex: 1; min-width: 200px;">
            <input
                type="text"
                id="filter-input"
                placeholder="Filter devices by name, IP, or type..."
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--surface1); border-radius: 4px; background: var(--base); color: var(--text);"
            />
        </div>
        <div style="display: flex; gap: 1rem; background: var(--mantle); padding: 0.5rem 0.75rem; border-radius: 6px; border: 1px solid var(--surface0);">
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; user-select: none;">
                <input
                    type="checkbox"
                    id="show-offline-checkbox"
                    checked
                    style="width: 16px; height: 16px; cursor: pointer; accent-color: var(--blue);"
                />
                <span style="font-size: 0.875rem; white-space: nowrap;">Show Offline</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; user-select: none;">
                <input
                    type="checkbox"
                    id="show-guests-checkbox"
                    checked
                    style="width: 16px; height: 16px; cursor: pointer; accent-color: var(--peach);"
                />
                <span style="font-size: 0.875rem; white-space: nowrap;">Show Guests</span>
            </label>
        </div>
    </div>

    <div class="mt-3" style="overflow-x: auto;">
        <table class="table">
            <thead>
                <tr>
                    <th class="sortable-header" data-column="name">Device Name</th>
                    <th class="sortable-header" data-column="type">Type</th>
                    <th class="sortable-header" data-column="ip_address">IP Address</th>
                    <th class="sortable-header" data-column="is_online">Status</th>
                    <th class="sortable-header" data-column="connection_type">Connection</th>
                    <th class="sortable-header" data-column="node">Node</th>
                    <th style="text-align: center; width: 60px;">Fwds</th>
                </tr>
            </thead>
            <tbody id="devices-table-body">
                <tr>
                    <td colspan="7" class="text-center text-muted">
                        Loading devices...
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Device Details Modal -->
<div id="device-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h2 class="modal-title" id="modal-title">Device Details</h2>
            <button class="modal-close" id="modal-close">&times;</button>
        </div>
        <div class="modal-body" id="modal-body">
            <!-- Content will be populated dynamically -->
        </div>
    </div>
</div>

<script>
    let devicesData = [];
    let currentSort = { column: 'name', direction: 'asc' };
    let filterText = '';
    let showOffline = true;
    let showGuests = true;

    // Routing data
    let reservationsMap = new Map(); // MAC -> reservation info
    let forwardsMap = new Map(); // IP -> array of forwards

    // Format device type with emoji and proper capitalization
    function formatDeviceType(type) {
        const typeMap = {
            'air_conditioner': '❄️ Air Conditioner',
            'car': '🚗 Car',
            'desktop_computer': '🖥️ Desktop Computer',
            'digital_assistant': '🔊 Digital Assistant',
            'door_bell': '🔔 Door Bell',
            'e_reader': '📖 E-Reader',
            'game_console': '🎮 Game Console',
            'garage_door': '🚪 Garage Door',
            'generic': '📱 Generic Device',
            'hard_drive': '💾 Hard Drive',
            'hub': '🔌 Hub',
            'laptop_computer': '💻 Laptop Computer',
            'light': '💡 Light',
            'media_streamer': '📺 Media Streamer',
            'network_equipment': '🌐 Network Equipment',
            'phone': '📱 Phone',
            'plug': '🔌 Plug',
            'printer': '🖨️ Printer',
            'security_camera': '📷 Security Camera',
            'tablet': '📱 Tablet',
            'television': '📺 Television',
            'thermostat': '🌡️ Thermostat',
            'unknown_computer': '💻 Unknown Computer',
            'vacuum': '🧹 Vacuum',
            'watch': '⌚ Watch'
        };

        // Return mapped value or formatted fallback
        if (typeMap[type]) {
            return typeMap[type];
        }

        // Fallback: convert snake_case to Title Case
        return '📱 ' + type.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    // Get current selected network
    function getSelectedNetwork() {
        const selector = document.getElementById('network-selector');
        return selector ? selector.value : null;
    }

    // Fetch devices from API
    async function loadDevices() {
        try {
            const network = getSelectedNetwork();
            const url = network ? `/api/devices?network=${encodeURIComponent(network)}` : '/api/devices';
            const response = await fetch(url);
            const data = await response.json();

            devicesData = data.devices || [];
            document.getElementById('device-count').textContent = devicesData.length;

            // Re-apply current sort if one is active
            if (currentSort.column) {
                applySortWithoutToggle();
            } else {
                renderDevices();
            }
        } catch (error) {
            console.error('Failed to load devices:', error);
            document.getElementById('devices-table-body').innerHTML = `
                <tr>
                    <td colspan="6" class="text-center text-muted">
                        Error loading devices. Please try refreshing the page.
                    </td>
                </tr>
            `;
        }
    }

    // Load routing configuration data
    async function loadRoutingData() {
        try {
            const notification = document.getElementById('routing-error-notification');
            let hasError = false;
            const network = getSelectedNetwork();

            // Load reservations
            const resUrl = network
                ? `/api/routing/reservations?network=${encodeURIComponent(network)}`
                : '/api/routing/reservations';
            const resResponse = await fetch(resUrl);
            if (resResponse.ok) {
                const resData = await resResponse.json();
                reservationsMap.clear();
                (resData.reservations || []).forEach(res => {
                    reservationsMap.set(res.mac_address, res);
                });
            } else {
                hasError = true;
            }

            // Load port forwards
            const fwdUrl = network
                ? `/api/routing/port-forwards?network=${encodeURIComponent(network)}`
                : '/api/routing/port-forwards';
            const fwdResponse = await fetch(fwdUrl);
            if (fwdResponse.ok) {
                const fwdData = await fwdResponse.json();
                forwardsMap.clear();
                (fwdData.forwards || []).forEach(fwd => {
                    if (!forwardsMap.has(fwd.ip_address)) {
                        forwardsMap.set(fwd.ip_address, []);
                    }
                    forwardsMap.get(fwd.ip_address).push(fwd);
                });
            } else {
                hasError = true;
            }

            // Show/hide error notification
            if (hasError) {
                notification.style.display = 'block';
            } else {
                notification.style.display = 'none';
            }

            // Re-render devices to show updated routing info
            renderDevices();
        } catch (error) {
            console.error('Failed to load routing data:', error);
            // Show error notification
            const notification = document.getElementById('routing-error-notification');
            if (notification) {
                notification.style.display = 'block';
            }
        }
    }

    // Sort devices
    function sortDevices(column) {
        if (currentSort.column === column) {
            // Toggle direction
            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            currentSort.column = column;
            currentSort.direction = 'asc';
        }

        applySortWithoutToggle();
    }

    // Apply current sort without toggling direction
    function applySortWithoutToggle() {
        const column = currentSort.column;

        devicesData.sort((a, b) => {
            let aVal = a[column];
            let bVal = b[column];

            // Handle null/undefined
            if (aVal == null) aVal = '';
            if (bVal == null) bVal = '';

            // Convert to lowercase for string comparison
            if (typeof aVal === 'string') aVal = aVal.toLowerCase();
            if (typeof bVal === 'string') bVal = bVal.toLowerCase();

            if (aVal < bVal) return currentSort.direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return currentSort.direction === 'asc' ? 1 : -1;
            return 0;
        });

        renderDevices();
        updateSortIndicators();
    }

    // Update sort indicators
    function updateSortIndicators() {
        document.querySelectorAll('.sortable-header').forEach(header => {
            header.classList.remove('sort-asc', 'sort-desc');
            if (header.dataset.column === currentSort.column) {
                header.classList.add(`sort-${currentSort.direction}`);
            }
        });
    }

    // Render devices table with filtering
    function renderDevices() {
        const tbody = document.getElementById('devices-table-body');

        if (devicesData.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center text-muted">
                        No devices found
                    </td>
                </tr>
            `;
            document.getElementById('visible-count').textContent = '0';
            return;
        }

        // Apply filters
        const filteredDevices = devicesData.filter(device => {
            // Filter by offline status
            if (!showOffline && !device.is_online) {
                return false;
            }

            // Filter by guest network status
            if (!showGuests && device.is_guest === true) {
                return false;
            }

            // Filter by text search
            if (filterText) {
                const searchLower = filterText.toLowerCase();
                const matchesName = device.name.toLowerCase().includes(searchLower);
                const matchesIP = device.ip_address.toLowerCase().includes(searchLower);
                const matchesType = device.type.toLowerCase().includes(searchLower);
                const matchesNode = device.node.toLowerCase().includes(searchLower);

                if (!matchesName && !matchesIP && !matchesType && !matchesNode) {
                    return false;
                }
            }

            return true;
        });

        // Update visible count
        document.getElementById('visible-count').textContent = filteredDevices.length;

        if (filteredDevices.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center text-muted">
                        No devices match the current filters
                    </td>
                </tr>
            `;
            return;
        }

        // Build the device index map for showDeviceDetails
        const deviceIndexMap = new Map();
        devicesData.forEach((device, index) => {
            deviceIndexMap.set(device, index);
        });

        tbody.innerHTML = filteredDevices.map(device => {
            const originalIndex = deviceIndexMap.get(device);
            const rowClass = device.is_online ? '' : 'offline';
            const statusBadge = device.is_online
                ? '<span class="status-badge status-online">Online</span>'
                : '<span class="status-badge status-offline">Offline</span>';

            // Check if IP is reserved
            const isReserved = reservationsMap.has(device.mac_address);
            const ipDisplay = isReserved ? `🔒 ${device.ip_address}` : device.ip_address;

            // Check for port forwards
            const forwards = forwardsMap.get(device.ip_address) || [];
            const forwardIndicator = forwards.length > 0
                ? `<span style="font-size: 1.25rem; title="${forwards.length} port forward(s)">🔀</span>`
                : '';

            // Guest network indicator
            const guestIndicator = device.is_guest
                ? `<span style="background: var(--peach); color: var(--base); padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 0.5rem;" title="Guest Network">GUEST</span>`
                : '';

            return `
                <tr class="device-row ${rowClass}" onclick="showDeviceDetails(${originalIndex})">
                    <td>${device.name}${guestIndicator}</td>
                    <td>${formatDeviceType(device.type)}</td>
                    <td>${ipDisplay}</td>
                    <td>${statusBadge}</td>
                    <td>${device.connection_type}</td>
                    <td>${device.node}</td>
                    <td style="text-align: center;">${forwardIndicator}</td>
                </tr>
            `;
        }).join('');
    }

    // Modal functions
    async function showDeviceDetails(deviceIndex) {
        const device = devicesData[deviceIndex];
        const modal = document.getElementById('device-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');

        // Set title
        modalTitle.textContent = device.name;

        // Check if network is in bridge mode
        let isBridgeMode = false;
        try {
            const network = getSelectedNetwork();
            const statsUrl = network ? `/api/dashboard-stats?network=${encodeURIComponent(network)}` : '/api/dashboard-stats';
            const statsResponse = await fetch(statsUrl);
            if (statsResponse.ok) {
                const stats = await statsResponse.json();
                isBridgeMode = stats.connection_mode && stats.connection_mode.toLowerCase() === 'bridge';
            }
        } catch (error) {
            console.error('Failed to check bridge mode:', error);
        }

        // Fetch reservation and forward data
        let reservationInfo = null;
        let forwardInfo = [];

        try {
            // Check if IP is reserved
            const resResponse = await fetch(`/api/routing/reservation/${encodeURIComponent(device.mac_address)}`);
            if (resResponse.ok) {
                reservationInfo = await resResponse.json();
            }

            // Get port forwards for this IP
            const fwdResponse = await fetch(`/api/routing/forwards/${encodeURIComponent(device.ip_address)}`);
            if (fwdResponse.ok) {
                const fwdData = await fwdResponse.json();
                forwardInfo = fwdData.forwards || [];
            }
        } catch (error) {
            console.error('Failed to load routing info:', error);
        }

        // Build the details HTML - start with bandwidth section
        let bandwidthSectionHtml = '';
        if (isBridgeMode) {
            // Bridge mode: show message instead of bandwidth
            bandwidthSectionHtml = `
            <div class="bandwidth-section" style="margin-top: 0; padding-top: 0; border-top: none;">
                <div class="bandwidth-header">
                    <div class="bandwidth-title">Bandwidth Usage</div>
                </div>
                <div style="padding: 2rem; text-align: center; background: var(--surface0); border-radius: 8px; color: var(--subtext0);">
                    <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">🌉</div>
                    <div style="font-weight: 600; color: var(--text); margin-bottom: 0.5rem;">Bridge Mode Active</div>
                    <div>Bandwidth calculations are not available in bridge mode</div>
                </div>
            </div>`;
        } else {
            // Router mode: show bandwidth chart
            bandwidthSectionHtml = `
            <div class="bandwidth-section" style="margin-top: 0; padding-top: 0; border-top: none;">
                <div class="bandwidth-header">
                    <div class="bandwidth-title">Bandwidth Usage</div>
                    <div class="interval-selector">
                        <button class="interval-btn" data-mode="hourly" onclick="updateBandwidthMode('${device.mac_address}', 'hourly')">Hourly</button>
                        <button class="interval-btn active" data-days="7" onclick="updateBandwidthDays('${device.mac_address}', 7)">7 Days</button>
                        <button class="interval-btn" data-days="30" onclick="updateBandwidthDays('${device.mac_address}', 30)">30 Days</button>
                    </div>
                </div>
                <div id="device-bandwidth-summary" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; margin-bottom: 1rem; padding: 0 0.25rem;">
                    <div style="text-align: center; padding: 0.5rem; background: var(--surface0); border-radius: 6px;">
                        <div style="font-size: 1.25rem; font-weight: 600; color: var(--blue);" id="device-period-download">--</div>
                        <div style="font-size: 0.75rem; color: var(--subtext0);">Download</div>
                    </div>
                    <div style="text-align: center; padding: 0.5rem; background: var(--surface0); border-radius: 6px;">
                        <div style="font-size: 1.25rem; font-weight: 600; color: var(--mauve);" id="device-period-upload">--</div>
                        <div style="font-size: 0.75rem; color: var(--subtext0);">Upload</div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="bandwidth-chart"></canvas>
                </div>
            </div>`;
        }

        // Start building the full details HTML with the bandwidth section
        let detailsHtml = bandwidthSectionHtml;

        // Add two-column layout for device details and aliases
        const aliasesValue = device.aliases ? device.aliases.join('\n') : '';
        detailsHtml += `
            <div class="details-grid">
                <div class="details-column">
                    <div class="info-row">
                        <div class="info-label">Type:</div>
                        <div class="info-value">${formatDeviceType(device.type)}</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Status:</div>
                        <div class="info-value">${device.is_online ? '<span style="color: var(--green);">● Online</span>' : '<span style="color: var(--subtext0);">● Offline</span>'}</div>
                    </div>
                    ${device.nickname ? `
                    <div class="info-row">
                        <div class="info-label">Nickname:</div>
                        <div class="info-value">${device.nickname}</div>
                    </div>` : ''}
                    ${device.hostname ? `
                    <div class="info-row">
                        <div class="info-label">Hostname:</div>
                        <div class="info-value">${device.hostname}</div>
                    </div>` : ''}
                    ${device.manufacturer ? `
                    <div class="info-row">
                        <div class="info-label">Manufacturer:</div>
                        <div class="info-value">${device.manufacturer}</div>
                    </div>` : ''}
                    <div class="info-row">
                        <div class="info-label">IP Address:</div>
                        <div class="info-value">
                            ${reservationInfo && reservationInfo.reserved ? '🔒 ' : ''}${device.ip_address}
                            ${reservationInfo && reservationInfo.reserved ? '<span style="color: var(--blue); font-size: 0.75rem; margin-left: 0.5rem;">(Reserved)</span>' : '<span style="color: var(--subtext1); font-size: 0.75rem; margin-left: 0.5rem;">(DHCP)</span>'}
                        </div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">MAC Address:</div>
                        <div class="info-value">${device.mac_address}</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Connection:</div>
                        <div class="info-value">${device.connection_type}</div>
                    </div>
                    ${device.signal_strength !== null && device.signal_strength !== undefined ? `
                    <div class="info-row">
                        <div class="info-label">Signal Strength:</div>
                        <div class="info-value">${device.signal_strength} dBm</div>
                    </div>` : ''}
                    ${device.bandwidth_down_mbps !== null && device.bandwidth_down_mbps !== undefined ? `
                    <div class="info-row">
                        <div class="info-label">Current Download:</div>
                        <div class="info-value">${device.bandwidth_down_mbps.toFixed(1)} Mbps</div>
                    </div>` : ''}
                    ${device.bandwidth_up_mbps !== null && device.bandwidth_up_mbps !== undefined ? `
                    <div class="info-row">
                        <div class="info-label">Current Upload:</div>
                        <div class="info-value">${device.bandwidth_up_mbps.toFixed(1)} Mbps</div>
                    </div>` : ''}
                    <div class="info-row">
                        <div class="info-label">Connected To:</div>
                        <div class="info-value">${device.node}</div>
                    </div>
                    ${device.last_seen ? `
                    <div class="info-row">
                        <div class="info-label">Last Seen:</div>
                        <div class="info-value">${formatTimestamp(device.last_seen)}</div>
                    </div>` : ''}
                </div>
                <div class="details-column">
                    <div class="aliases-label">DNS Aliases</div>
                    <textarea id="aliases-textarea" class="aliases-textarea" placeholder="Enter DNS aliases, one per line">${aliasesValue}</textarea>
                    <div class="aliases-help">Each alias will be added as an alternate DNS name for this device</div>
                    <button id="save-aliases-btn" class="save-button">Save Aliases</button>
                    <div id="save-message" class="save-message"></div>

                    ${forwardInfo.length > 0 ? `
                    <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--surface0);">
                        <div class="aliases-label">Port Forwards</div>
                        <div style="background: var(--surface0); border-radius: 6px; padding: 0.75rem; margin-top: 0.5rem;">
                            ${forwardInfo.map(fwd => `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; ${forwardInfo.indexOf(fwd) < forwardInfo.length - 1 ? 'border-bottom: 1px solid var(--surface1);' : ''}">
                                    <div>
                                        <div style="font-weight: 600; color: var(--text);">${fwd.description || 'Forward'}</div>
                                        <div style="font-size: 0.75rem; color: var(--subtext0); margin-top: 0.25rem;">
                                            Port <strong>${fwd.gateway_port}</strong> → ${fwd.client_port}
                                        </div>
                                    </div>
                                    <div>
                                        <span style="background: var(--${fwd.protocol === 'tcp' ? 'blue' : fwd.protocol === 'udp' ? 'mauve' : 'green'}); color: var(--base); padding: 0.125rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600;">${fwd.protocol.toUpperCase()}</span>
                                        ${!fwd.enabled ? '<span style="color: var(--red); font-size: 0.75rem; margin-left: 0.5rem;">⚠ Disabled</span>' : ''}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="font-size: 0.75rem; color: var(--subtext1); margin-top: 0.5rem;">
                            ${forwardInfo.length} active port forward${forwardInfo.length !== 1 ? 's' : ''}
                        </div>
                    </div>
                    ` : ''}
                </div>
            </div>
        `;

        modalBody.innerHTML = detailsHtml;

        // Store device MAC for saving
        modalBody.dataset.deviceMac = device.mac_address;

        modal.classList.add('active');

        // Add event listener for save button
        document.getElementById('save-aliases-btn').addEventListener('click', () => saveAliases(device.mac_address));

        // Load bandwidth data (only if not in bridge mode)
        if (!isBridgeMode) {
            loadBandwidthChart(device.mac_address, 7);
        }
    }

    function hideModal() {
        const modal = document.getElementById('device-modal');
        modal.classList.remove('active');
    }

    function formatTimestamp(isoString) {
        if (!isoString) return 'N/A';
        const date = new Date(isoString);
        return date.toLocaleString();
    }

    // Save aliases to server
    async function saveAliases(macAddress) {
        const textarea = document.getElementById('aliases-textarea');
        const saveBtn = document.getElementById('save-aliases-btn');
        const saveMessage = document.getElementById('save-message');

        // Get aliases from textarea (one per line)
        const aliasesText = textarea.value;
        const aliases = aliasesText
            .split('\n')
            .map(line => line.trim())
            .filter(line => line.length > 0);

        // Disable button and show loading
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
        saveMessage.className = 'save-message';
        saveMessage.textContent = '';

        try {
            const response = await fetch(`/api/devices/${encodeURIComponent(macAddress)}/aliases`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ aliases: aliases }),
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            // Show success message
            saveMessage.className = 'save-message success';
            saveMessage.textContent = `Aliases saved successfully! DNS updated.`;

            // Update the device in our local data
            const deviceIndex = devicesData.findIndex(d => d.mac_address === macAddress);
            if (deviceIndex !== -1) {
                devicesData[deviceIndex].aliases = data.aliases;
            }

            // Hide message after 3 seconds
            setTimeout(() => {
                saveMessage.className = 'save-message';
            }, 3000);

        } catch (error) {
            console.error('Failed to save aliases:', error);
            saveMessage.className = 'save-message error';
            saveMessage.textContent = `Error saving aliases: ${error.message}`;
        } finally {
            // Re-enable button
            saveBtn.disabled = false;
            saveBtn.textContent = 'Save Aliases';
        }
    }

    // Bandwidth chart variables
    let bandwidthChart = null;
    let currentDays = 7;
    let currentMode = 'daily';  // 'hourly' or 'daily'

    // Format bytes to human readable format
    function formatBytes(mb) {
        if (mb >= 1000) {
            return `${(mb / 1000).toFixed(2)} GB`;
        } else if (mb >= 1) {
            return `${mb.toFixed(2)} MB`;
        } else if (mb >= 0.001) {
            // Convert MB to KB (1 MB = 1024 KB)
            return `${(mb * 1024).toFixed(2)} KB`;
        } else if (mb > 0) {
            // Convert MB to Bytes (1 MB = 1024 * 1024 Bytes)
            return `${(mb * 1024 * 1024).toFixed(0)} Bytes`;
        }
        return '0 Bytes';
    }

    // Load and render bandwidth chart for device
    async function loadBandwidthChart(macAddress, days) {
        try {
            const response = await fetch(`/api/devices/${encodeURIComponent(macAddress)}/bandwidth-total?days=${days}`);
            const data = await response.json();

            if (!data.daily_breakdown || data.daily_breakdown.length === 0) {
                console.log('No bandwidth data available for device');
                showNoDataMessage();
                return;
            }

            // Update summary
            document.getElementById('device-period-download').textContent = formatBytes(data.totals.download_mb);
            document.getElementById('device-period-upload').textContent = formatBytes(data.totals.upload_mb);

            // Render bar chart
            renderBandwidthChart(data.daily_breakdown);
        } catch (error) {
            console.error('Failed to load bandwidth chart:', error);
            showNoDataMessage();
        }
    }

    function showNoDataMessage() {
        const chartContainer = document.querySelector('.bandwidth-section .chart-container');
        if (chartContainer) {
            chartContainer.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--subtext0);">Bandwidth data is accumulating... Check back soon!</div>';
        }
    }

    // Render bandwidth bar chart
    function renderBandwidthChart(dailyData) {
        const ctx = document.getElementById('bandwidth-chart');
        if (!ctx) return;

        // Destroy existing chart
        if (bandwidthChart) {
            bandwidthChart.destroy();
        }

        const labels = dailyData.map(d => d.date);
        const downloadData = dailyData.map(d => d.download_mb);
        const uploadData = dailyData.map(d => d.upload_mb);

        // Use lighter colors for incomplete (today's) data
        const downloadColors = dailyData.map(d =>
            d.is_incomplete ? 'rgba(30, 102, 245, 0.4)' : 'rgba(30, 102, 245, 0.8)'
        );
        const uploadColors = dailyData.map(d =>
            d.is_incomplete ? 'rgba(136, 57, 239, 0.4)' : 'rgba(136, 57, 239, 0.8)'
        );

        bandwidthChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Download',
                        data: downloadData,
                        backgroundColor: downloadColors,
                        borderColor: 'rgb(30, 102, 245)',
                        borderWidth: 1
                    },
                    {
                        label: 'Upload',
                        data: uploadData,
                        backgroundColor: uploadColors,
                        borderColor: 'rgb(136, 57, 239)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                // Parse as local date to avoid timezone shift
                                const dateStr = context[0].label;
                                const [year, month, day] = dateStr.split('-').map(Number);
                                const date = new Date(year, month - 1, day);
                                const formatted = date.toLocaleDateString('en-US', {
                                    weekday: 'short',
                                    month: 'short',
                                    day: 'numeric'
                                });
                                // Add note for incomplete data
                                const dataPoint = dailyData[context[0].dataIndex];
                                return dataPoint.is_incomplete ? formatted + ' (incomplete)' : formatted;
                            },
                            label: function(context) {
                                return `${context.dataset.label}: ${formatBytes(context.parsed.y)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'category',  // Explicitly use category scale to prevent date parsing
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Date'
                        },
                        ticks: {
                            callback: function(value, index) {
                                // Parse as local date to avoid timezone shift
                                const dateStr = this.getLabelForValue(value);
                                const [year, month, day] = dateStr.split('-').map(Number);
                                const date = new Date(year, month - 1, day);
                                return date.toLocaleDateString('en-US', {
                                    month: 'short',
                                    day: 'numeric'
                                });
                            }
                        }
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Data Usage'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatBytes(value);
                            }
                        }
                    }
                }
            }
        });
    }

    // Update bandwidth days (called from button onclick)
    function updateBandwidthDays(macAddress, days) {
        currentDays = days;
        currentMode = 'daily';

        // Update button states
        document.querySelectorAll('.interval-btn').forEach(btn => {
            btn.classList.remove('active');
            if (parseInt(btn.dataset.days) === days) {
                btn.classList.add('active');
            }
        });

        // Reload chart with new days
        loadBandwidthChart(macAddress, days);
    }

    // Update bandwidth mode (called from button onclick)
    function updateBandwidthMode(macAddress, mode) {
        currentMode = mode;

        // Update button states
        document.querySelectorAll('.interval-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.mode === mode) {
                btn.classList.add('active');
            }
        });

        // Load hourly chart
        loadBandwidthHourlyChart(macAddress);
    }

    // Load and render hourly bandwidth chart for device
    async function loadBandwidthHourlyChart(macAddress) {
        try {
            const response = await fetch(`/api/devices/${encodeURIComponent(macAddress)}/bandwidth-history?hours=24`);
            const data = await response.json();

            if (!data.history || data.history.length === 0) {
                console.log('No bandwidth history available for device');
                showNoDataMessage();
                return;
            }

            // Get today's date at midnight (local timezone)
            const now = new Date();
            const todayMidnight = new Date(now.getFullYear(), now.getMonth(), now.getDate());

            // Aggregate data by hour
            const hourlyData = Array(24).fill(null).map((_, hour) => ({
                hour: hour,
                hour_label: `${hour.toString().padStart(2, '0')}:00`,
                download_mb: 0,
                upload_mb: 0,
                count: 0
            }));

            // Sum bandwidth rates for each hour (convert Mbps to MB by dividing by 8 and multiplying by collection interval)
            // Only include data from today (local timezone)
            const secondsPerDataPoint = 30; // 30-second collection intervals
            data.history.forEach(point => {
                // Parse timezone-aware timestamp (API returns ISO timestamps with timezone offset)
                const timestamp = new Date(point.timestamp);

                // Filter: only include timestamps >= today at midnight
                if (timestamp >= todayMidnight) {
                    const hour = timestamp.getHours();
                    if (point.download_mbps !== null && point.upload_mbps !== null) {
                        hourlyData[hour].download_mb += (point.download_mbps * secondsPerDataPoint) / 8;
                        hourlyData[hour].upload_mb += (point.upload_mbps * secondsPerDataPoint) / 8;
                        hourlyData[hour].count++;
                    }
                }
            });

            // Calculate totals
            const totalDownload = hourlyData.reduce((sum, h) => sum + h.download_mb, 0);
            const totalUpload = hourlyData.reduce((sum, h) => sum + h.upload_mb, 0);

            // Update summary
            document.getElementById('device-period-download').textContent = formatBytes(totalDownload);
            document.getElementById('device-period-upload').textContent = formatBytes(totalUpload);

            // Render bar chart with hourly data
            renderBandwidthChartHourly(hourlyData);
        } catch (error) {
            console.error('Failed to load hourly bandwidth chart:', error);
            showNoDataMessage();
        }
    }

    // Render bandwidth bar chart for hourly data
    function renderBandwidthChartHourly(hourlyData) {
        const ctx = document.getElementById('bandwidth-chart');
        if (!ctx) return;

        // Destroy existing chart
        if (bandwidthChart) {
            bandwidthChart.destroy();
        }

        const labels = hourlyData.map(h => h.hour_label);
        const downloadData = hourlyData.map(h => h.download_mb);
        const uploadData = hourlyData.map(h => h.upload_mb);

        bandwidthChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Download',
                        data: downloadData,
                        backgroundColor: 'rgba(30, 102, 245, 0.8)', // Catppuccin blue
                        borderColor: 'rgb(30, 102, 245)',
                        borderWidth: 1
                    },
                    {
                        label: 'Upload',
                        data: uploadData,
                        backgroundColor: 'rgba(136, 57, 239, 0.8)', // Catppuccin mauve
                        borderColor: 'rgb(136, 57, 239)',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            title: function(context) {
                                return context[0].label;
                            },
                            label: function(context) {
                                return `${context.dataset.label}: ${formatBytes(context.parsed.y)}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'category',  // Explicitly use category scale to prevent parsing issues
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Hour'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        stacked: false,
                        title: {
                            display: true,
                            text: 'Data Usage'
                        },
                        ticks: {
                            callback: function(value) {
                                return formatBytes(value);
                            }
                        }
                    }
                }
            }
        });
    }

    // Modal event listeners
    document.getElementById('modal-close').addEventListener('click', hideModal);
    document.getElementById('device-modal').addEventListener('click', (e) => {
        if (e.target.id === 'device-modal') {
            hideModal();
        }
    });

    // Close modal on Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            hideModal();
        }
    });

    // Add click handlers to sortable headers
    document.querySelectorAll('.sortable-header').forEach(header => {
        header.addEventListener('click', () => {
            sortDevices(header.dataset.column);
        });
    });

    // Add filter event listeners
    document.getElementById('filter-input').addEventListener('input', (e) => {
        filterText = e.target.value;
        renderDevices();
    });

    document.getElementById('show-offline-checkbox').addEventListener('change', (e) => {
        showOffline = e.target.checked;
        renderDevices();
    });

    document.getElementById('show-guests-checkbox').addEventListener('change', (e) => {
        showGuests = e.target.checked;
        renderDevices();
    });

    // Load networks and populate dropdown
    async function loadNetworks() {
        try {
            const response = await fetch('/api/networks');
            const data = await response.json();

            const selector = document.getElementById('network-selector');
            selector.innerHTML = '';  // Clear existing options

            if (data.networks && data.networks.length > 0) {
                // Get selected network from localStorage (or default to first)
                const savedNetwork = localStorage.getItem('selectedNetwork');

                data.networks.forEach((network, index) => {
                    const option = document.createElement('option');
                    option.value = network.name;
                    option.textContent = `${network.name} (${network.nickname_label})`;

                    // Check if this is the saved network
                    if (savedNetwork === network.name) {
                        option.selected = true;
                    } else if (!savedNetwork && index === 0) {
                        option.selected = true;
                    }

                    selector.appendChild(option);
                });

                // Save selected network on change and reload data
                selector.addEventListener('change', function() {
                    localStorage.setItem('selectedNetwork', this.value);
                    // Reload all data for the new network
                    loadDevices();
                    loadRoutingData();
                });
            } else {
                selector.innerHTML = '<option value="">No networks available</option>';
            }
        } catch (error) {
            console.error('Failed to load networks:', error);
            document.getElementById('network-selector').innerHTML = '<option value="">Error loading networks</option>';
        }
    }

    // Initial load
    async function initialize() {
        await loadNetworks();  // Wait for networks to load first
        loadDevices();
        loadRoutingData();
    }
    initialize();

    // Refresh every 30 seconds (devices) and every 60 seconds (routing)
    setInterval(loadDevices, 30000);
    setInterval(loadRoutingData, 60000); // Routing data changes less frequently
</script>
{% endblock %}
